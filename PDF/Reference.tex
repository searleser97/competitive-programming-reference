% run the command ' lualatex -shell-escape Reference.tex ' twice in the terminal to visualize table of contents
\documentclass[twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{multicol}
\usepackage{minted}
\usepackage{python}
\usepackage[hidelinks]{hyperref}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{pdfpages}
\usepackage{needspace}
\usepackage{sectsty}
\usepackage{array}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage{afterpage}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[inline]{enumitem}
\usepackage{fontspec}

\geometry{letterpaper, portrait, left=0.5cm, right=0.5cm, top=1.8cm, bottom=1cm}

\setminted{
    style=tango,
    breaklines=true
}

\setlength{\headsep}{0.5cm}
\setlength{\columnsep}{0.5cm}
\setlength{\columnseprule}{0.01cm}
\renewcommand{\columnseprulecolor}{\color{gray}}

\pagestyle{fancy}
\pagenumbering{arabic}
\fancyhead{}
\fancyfoot{}
\fancyhead[LO,RE]{\textsf{First, solve the problem. Then, write the code.}}
\fancyhead[LE,RO]{\textsf{\leftmark}}
\fancyfoot[LE,RO]{\textbf{\textsf{\thepage}}}

\renewcommand{\headrulewidth}{0.01cm}
\renewcommand{\footrulewidth}{0.01cm}

\setlength{\parindent}{0em}
% column space
\setlength{\tabcolsep}{10pt} % Default value: 6pt
% upper and lower padding
\renewcommand{\arraystretch}{1.5} % Default value: 1

\definecolor{prussianblue}{rgb}{0.0, 0.19, 0.33}
\definecolor{indigo(dye)}{rgb}{0.0, 0.25, 0.42}
\definecolor{lapislazuli}{rgb}{0.15, 0.38, 0.61}
\definecolor{mediumelectricblue}{rgb}{0.01, 0.31, 0.59}
\definecolor{smalt(darkpowderblue)}{rgb}{0.0, 0.2, 0.6}
\definecolor{yaleblue}{rgb}{0.06, 0.3, 0.57}
\definecolor{skobeloff}{rgb}{0.0, 0.48, 0.45}
\definecolor{pinegreen}{rgb}{0.0, 0.47, 0.44}

\newcommand{\fileTitleStyle}{\large\underline}

\sectionfont{\centering\bfseries\Huge}
\subsectionfont{\centering\bfseries\LARGE}
\subsubsectionfont{\centering\bfseries\Large}
\paragraphfont{\centering\bfseries\large}

\setmainfont{CMU Bright}

\begin{document}
\includepdf{"/home/san/Projects/competitive-programming-reference/LaTex Template/TitlePage/TitlePage.pdf"}
\thispagestyle{empty}
\cleardoublepage
\begin{multicols*}{2}
    \tableofcontents
\end{multicols*}
\begin{multicols*}{2}
\needspace{32\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Coding Resources}
\markboth{CODING RESOURCES}{}
\addcontentsline{toc}{section}{Coding Resources}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{C++}
\addcontentsline{toc}{subsection}{C++}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Competitive Programming Template}
\addcontentsline{toc}{subsubsection}{Competitive Programming Template}
\begin{minted}{cpp}
#include <bits/stdc++.h>
using namespace std;
#define coutc "\033[48;5;196m\033[38;5;15m"
#define endc "\033[0m"
#define endl '\n'
#define M(_1, _2, _3, _4, NAME, ...) NAME
#define rep(...) \
  M(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)
#define rep4(_, x, n, s) \
  for (int _ = x; (s < 0) ? _ > n : _ < n; _ += s)
#define rep3(_, x, n) rep4(_, x, n, (x < n ? 1 : -1))
#define rep2(_, n) rep3(_, 0, n)
#define rep1(n) rep2(i, n)
#define fi first
#define se second
#define pb push_back
#define pii pair<int, int>
#define all(x) x.begin(), x.end()
#define len(x) int(x.size())
#define lli __int128_t
#define li long long int
#define ld long double
#ifdef DEBUG
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
ostream &operator<<(ostream &o, pair<auto, auto> p) {
  return o << "(" << p.fi << ", " << p.se << ")";
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
ostream &operator<<(ostream &o, vector<auto> v) {
  rep(i, len(v)) o << setw(7) << right << v[i];
  return o << endc << endl << coutc;
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
ostream &operator<<(ostream &o, map<auto, auto> m) {
  for (auto &kv : m) o << kv;
  return o;
}
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
void debug(const auto &e, const auto &... r) {
  cerr << coutc << e;
  ((cerr << " " << r), ..., (cerr << endc << endl));
}
#else
#define debug(...)
#endif
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
void _main(int tc) {

}
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  _main(0), exit(0);
  int tc;
  cin >> tc;
  rep(i, tc) _main(i + 1);
}
\end{minted}

\needspace{4\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Include All Libraries}
\addcontentsline{toc}{subsubsection}{Include All Libraries}
\begin{minted}{cpp}
#include <bits/stdc++.h>
using namespace std;
\end{minted}

\needspace{6\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{IO Optimization}
\addcontentsline{toc}{subsubsection}{IO Optimization}
\begin{minted}{cpp}
int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
}
\end{minted}

\needspace{12\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Number To String}
\addcontentsline{toc}{subsubsection}{Number To String}
\begin{minted}{cpp}
#include <bits/stdc++.h>
using namespace std;

int main() {
  // to_string method converts any type of number
  // (int, double, long long int, ...) to string
  string str = "str+" + to_string(123 + 1);
  cout << str << endl;  // output: str+124
  return 0;
}
\end{minted}

\needspace{9\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Ordered Set}
\addcontentsline{toc}{subsubsection}{Ordered Set}
\begin{minted}{cpp}
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

#define ordered_set                            \
  tree<int, null_type, less<int>, rb_tree_tag, \
       tree_order_statistics_node_update>
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
int main() {
  vector<int> v = {3, 1, 5, 2};
  ordered_set os(v.begin(), v.end());
  // prints 3 which is the element in index 2
  cout << *(os.find_by_order(2)) << endl;
  // prints 2 which is the number of items
  // strictly smaller than 3
  cout << os.order_of_key(3)  << endl;
}
\end{minted}

\needspace{20\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Output Format}
\addcontentsline{toc}{subsubsection}{Output Format}
\begin{minted}{cpp}
int main() {
  ios state(nullptr);
  state.copyfmt(cout);  // saves current format state
  double D = 13.34567;
  cout << setprecision(4) << D << endl  // 13.35
       << fixed << D << endl;           // 13.3457
  cout.copyfmt(state);  // restores format
  int N = 13;
  cout << setw(4) << N << endl       // "  13"
       << setfill('0') << N << endl  // "0013"
       << left << N << endl          // "1300"
       << right << N << endl         // "0013"
       << hex << N << endl           // "000d"
       << uppercase << N << endl     // "000D"
       << nouppercase << N << endl   // "000d"
       << oct << N << endl           // "0015"
       << dec << N << endl;          // "0013"
}
\end{minted}

\needspace{12\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Permutations}
\addcontentsline{toc}{subsubsection}{Permutations}
\begin{minted}{cpp}
typedef vector<int> T;  // typedef string T;

vector<T> permutations(T v) {
  vector<vector<int>> ans;
  sort(v.begin(), v.end());
  do
    ans.push_back(v);
  while (next_permutation(v.begin(), v.end()));
  return ans;
}
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Print Vector}
\addcontentsline{toc}{subsubsection}{Print Vector}
\begin{minted}{cpp}
void printv(vector<int> v) {
  if (v.size() == 0) {
    cout << "[]" << endl;
    return;
  }
  cout << "[" << v[0];
  for (int i = 1; i < v.size(); i++)
    cout << ", " << v[i];
  cout << "]" << endl;
}
\end{minted}

\needspace{5\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Priority Queue With Given Comparator Function}
\addcontentsline{toc}{subsubsection}{Priority Queue With Given Comparator Function}
\begin{minted}{cpp}
struct Object {
  int x, y;
};
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
int main() {
  auto cmp = [](const Object& a, const Object& b) {
    return a.x > b.x;
  };
  priority_queue<Object, vector<Object>,
                 decltype(cmp)> pq(cmp);
}
\end{minted}

\needspace{10\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Random}
\addcontentsline{toc}{subsubsection}{Random}
\begin{minted}{cpp}
mt19937_64 seed(chrono::steady_clock::now()
                    .time_since_epoch()
                    .count());

int random(int min, int max) {  // [min, max]
  return uniform_int_distribution<int>(min,
                                       max)(seed);
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
double random(double min, double max) {  // [min, max)
  return uniform_real_distribution<double>(min,
                                           max)(seed);
}
\end{minted}

\needspace{9\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Read Line}
\addcontentsline{toc}{subsubsection}{Read Line}
\begin{minted}{cpp}
// when reading lines, don't mix 'cin' with
// 'getline' just use getline and split
string input() {
  string ans;
  getline(cin, ans);
  return ans;
}
\end{minted}

\needspace{12\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Secure Hash}
\addcontentsline{toc}{subsubsection}{Secure Hash}
\begin{minted}{cpp}
struct myhash {
  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now()
            .time_since_epoch()
            .count();
    x ^= FIXED_RANDOM;
    return x ^ (x >> 16);
  }
};
\end{minted}

\needspace{6\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Set of Object}
\addcontentsline{toc}{subsubsection}{Set of Object}
\begin{minted}{cpp}
struct Object {
  char first;
  int second;
};
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
int main() {
  auto cmp = [](const Object& a, const Object& b) {
    return a.second > b.second;
  };
  set<Object, decltype(cmp)> pq(cmp);
}
\end{minted}

\needspace{6\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Set With Given Comparator Function}
\addcontentsline{toc}{subsubsection}{Set With Given Comparator Function}
\begin{minted}{cpp}
int main() {
  auto comp = [](int x, int y) { return x < y; };
  set<int, decltype(comp)> myset(comp);
}
\end{minted}

\needspace{6\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Sort Vector Of Object}
\addcontentsline{toc}{subsubsection}{Sort Vector Of Object}
\begin{minted}{cpp}
struct Object {
  char first;
  int second;
};
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
bool cmp(const Object& a, const Object& b) {
  return a.second > b.second;
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
int main() {
  vector<Object> v = {{'c', 3}, {'a', 1}, {'b', 2}};
  sort(v.begin(), v.end(), cmp);
}
\end{minted}

\needspace{5\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Sort Vector of Pairs}
\addcontentsline{toc}{subsubsection}{Sort Vector of Pairs}
\begin{minted}{cpp}
vector<pair<int, int>> pairs;
// sorts array on the basis of the first element
sort(pairs.begin(), pairs.end());

\end{minted}

\needspace{10\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Split String}
\addcontentsline{toc}{subsubsection}{Split String}
\begin{minted}{cpp}
vector<string> split(string str, char token) {
  stringstream ss(str);
  vector<string> v;
  while (getline(ss, str, token)) v.push_back(str);
  return v;
}
\end{minted}

\needspace{13\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{String To Int}
\addcontentsline{toc}{subsubsection}{String To Int}
\begin{minted}{cpp}
#include <bits/stdc++.h>
using namespace std;

int main() {
  int n = stoi("123") + 1;
  cout << n << endl;  // output: 124
  // stoll for long long int
  // stoull for unsigned long int
  // stod for double
  // stold for long double
}
\end{minted}

\needspace{6\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Substring}
\addcontentsline{toc}{subsubsection}{Substring}
\begin{minted}{cpp}
// [l, r)
string substr(string &s, int l, int r) {
  return string(s.begin() + l, s.begin() + r);
}
\end{minted}

\needspace{5\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Typedef}
\addcontentsline{toc}{subsubsection}{Typedef}
\begin{minted}{cpp}
typedef TYPE ALIAS;
// example:
typedef int T;
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Unordered Map with pair as key}
\addcontentsline{toc}{subsubsection}{Unordered Map with pair as key}
\begin{minted}{cpp}
typedef int T;

struct pairhash {
  template <class T1, class T2>
  size_t operator()(const pair<T1, T2> &p) const {
    return hash<T1>{}(p.first) ^
           (hash<T2>{}(p.second) << 32);
  }
};
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
int main() {
  unordered_map<pair<int, int>, T, pairhash> um;
  um[{1, 2}] = 5;
  cout << um[{1, 2}] << endl;
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Python}
\addcontentsline{toc}{subsection}{Python}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Combinations}
\addcontentsline{toc}{subsubsection}{Combinations}
\begin{minted}{py}
import itertools
# from arr choose k = > combinations(arr, k)
print(list(itertools.combinations([1, 2, 3], 3)))
\end{minted}

\needspace{17\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Fast IO}
\addcontentsline{toc}{subsubsection}{Fast IO}
\begin{minted}{py}
from sys import stdin, stdout

N = 10
# Reads N chars from stdin(it counts '\n' as char)
stdin.read(N)
# Reads until '\n' or EOF
line = stdin.readline()
# Reads all lines in stdin until EOF
lines = stdin.readlines()
# Writes a string to stdout, it doesn't add '\n'
stdout.write(line)
# Writes a list of strings to stdout
stdout.writelines(lines)
# Reads numbers separated by space in a line
numbers = list(map(int, stdin.readline().split()))

\end{minted}

\needspace{4\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Permutations}
\addcontentsline{toc}{subsubsection}{Permutations}
\begin{minted}{py}
import itertools
print(list(itertools.permutations([1, 2, 3])))

\end{minted}

\needspace{15\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Random}
\addcontentsline{toc}{subsubsection}{Random}
\begin{minted}{py}
import random
# Initialize the random number generator.
random.seed(None)
# Returns a random integer N such that a <= N <= b.
random.randint(a, b)
# Returns a random integer N such that 0 <= N < b
random.randrange(b)
# Returns a random integer N such that a <= N < b.
random.randrange(a, b)
# Returns and integer with k random bits.
random.getrandbits(k)
# shuffles a list
random.shuffle(li)
\end{minted}

\needspace{7\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Sort List}
\addcontentsline{toc}{subsubsection}{Sort List}
\begin{minted}{py}
li = ['a', 'c', 'b']
# sorts inplace in descending order
li.sort(reverse=True)
# returns sorted list ascending order
ol = sorted(li)
\end{minted}

\needspace{7\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Sort List Of Object}
\addcontentsline{toc}{subsubsection}{Sort List Of Object}
\begin{minted}{py}
class MyObject :
  def __init__(self, first, second, third):
    self.first = first
    self.second = second
    self.third = third
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{py}
li = [MyObject('b', 3, 1), MyObject('a', 3, 2), MyObject('b', 3, 3)]
# returns list sorted by first then by second then by third in increasing order
ol = sorted(li, key = lambda x: (x.first, x.second, x.third), reverse=False)
# sorts inplace by first then by second then by third in increasing order
li.sort(key = lambda x: (x.first, x.second, x.third), reverse=False)

\end{minted}

\needspace{20\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{BITs Manipulation}
\markboth{BITS MANIPULATION}{}
\addcontentsline{toc}{section}{BITs Manipulation}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{All Possible Subsets}
\addcontentsline{toc}{subsection}{All Possible Subsets}
\begin{minted}{cpp}
// O(2^n)
vector<vector<int>> allSubsets(vector<int>& nums) {
  vector<vector<int>> ans;
  int limit = 1 << nums.size();
  for (int i = 0; i < limit; i++) {
    vector<int> aux;
    for (int j = 0; j < nums.size(); j++) {
      if (i & (1 << j)) aux.push_back(nums[j]);
    }
    ans.push_back(aux);
  }
  return ans;
}
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Bit Count}
\addcontentsline{toc}{subsection}{Bit Count}
\begin{minted}{cpp}
int bitCount(int n) {
  return sizeof(n) * 8 - __builtin_clz(n);
}
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
int bitCount(int n) {
  int c = 0;
  while (n) c++, n >>= 1;
  return c;
}
\end{minted}

\needspace{13\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Bits To Int}
\addcontentsline{toc}{subsection}{Bits To Int}
\begin{minted}{cpp}
typedef __int128_t lli

lli bitsToInt(string bits, bool isneg) {
  lli ans = 0;
  for (int i = bits.size() - 1, j = 0; ~i; i--, j++) {
    if (isneg) bits[i] = bits[i] == '0' ? '1' : '0';
    ans |= (lli)(bits[i] - '0') << j;
  }
  return isneg ? -(++ans) : ans;
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Count Leading Zeroes}
\addcontentsline{toc}{subsection}{Count Leading Zeroes}
\begin{minted}{cpp}
int clz(int n) {
  return __builtin_clz(n);
  // return __builtin_clzl(n); for long
  // return __builtin_clzll(n); for long long
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
int clz(int n) {
  // return sizeof(n) * 8 - bitCount(n);
  int c = 0;
  while (n) c++, n >>= 1;
  return sizeof(n) * 8 - c;
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Count Set Bits}
\addcontentsline{toc}{subsection}{Count Set Bits}
\begin{minted}{cpp}
int popCount(int n) {
  return __builtin_popcount(n);
  // return __builtin_popcountl(n); for long
  // return __builtin_popcountll(n); for long long
}
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
int popCount(int n) {
  int c = 0;
  while (n) c++, n &= n - 1;
  return c;
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Count Trailing Zeroes}
\addcontentsline{toc}{subsection}{Count Trailing Zeroes}
\begin{minted}{cpp}
int ctz(int n) {
  return __builtin_ctz(n);
  // return __builtin_ctzl(n); for long
  // return __builtin_ctzll(n); for long long
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
int ctz(int n) {
  int c = 0;
  n = ~n;
  while(n & 1) c++, n >>= 1;
  return c;
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Divide By 2}
\addcontentsline{toc}{subsection}{Divide By 2}
\begin{minted}{cpp}
int divideBy2(int n) { return n >> 1; }
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Is Even}
\addcontentsline{toc}{subsection}{Is Even}
\begin{minted}{cpp}
bool isEven(int n) { return ~n & 1; }
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Is i-th Bit Set}
\addcontentsline{toc}{subsection}{Is i-th Bit Set}
\begin{minted}{cpp}
bool isIthBitSet(int n, int i) {
  return n & (1 << i);
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Is Odd}
\addcontentsline{toc}{subsection}{Is Odd}
\begin{minted}{cpp}
bool isOdd(int n) { return n & 1; }
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Is Power Of 2}
\addcontentsline{toc}{subsection}{Is Power Of 2}
\begin{minted}{cpp}
bool isPowerOf2(int n) { return n && !(n & (n - 1)); }
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Least Significant Set Bit}
\addcontentsline{toc}{subsection}{Least Significant Set Bit}
\begin{minted}{cpp}
int lsb(int n) { return n & -n; }
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Log2}
\addcontentsline{toc}{subsection}{Log2}
\begin{minted}{cpp}
int Log2(int n) {
  return sizeof(n) * 8 - __builtin_clz(n) - 1;
}
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
int Log2(int n) {
  int lg2 = 0;
  while (n >>= 1) lg2++;
  return lg2;
}
\end{minted}

\needspace{5\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Modulo With Power Of 2}
\addcontentsline{toc}{subsection}{Modulo With Power Of 2}
\begin{minted}{cpp}
// b must be a power of 2
int mod(int a, int b) { return a & (b - 1); }
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Most Significant Set Bit}
\addcontentsline{toc}{subsection}{Most Significant Set Bit}
\begin{minted}{cpp}
int msb(int n) {
  return 1 << (sizeof(n) * 8 - __builtin_clz(n) - 1);
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Multiply By 2}
\addcontentsline{toc}{subsection}{Multiply By 2}
\begin{minted}{cpp}
int multiplyBy2(int n) { return n << 1; }
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{One's Complement}
\addcontentsline{toc}{subsection}{One's Complement}
\begin{minted}{cpp}
int onesComplement(int n) { return ~n; }
\end{minted}

\needspace{10\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Parity Check}
\addcontentsline{toc}{subsection}{Parity Check}
\begin{minted}{cpp}
#include "Count Set Bits.cpp"
#include "Is Even.cpp"
bool parityCheck(int n) {
  return !__builtin_parity(n);
  // return !__builtin_parityl(n); for long
  // return !__builtin_parityll(n); for long long
}
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
bool parityCheck(int n) {
  return isEven(popCount(n));
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Print Bits}
\addcontentsline{toc}{subsection}{Print Bits}
\begin{minted}{cpp}
void printBits(int n) {
  for (int i = sizeof(n) * 8 - 1; ~i; i--)
    cout << ((n >> i) & 1);
  cout << endl;
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Set i-th Bit}
\addcontentsline{toc}{subsection}{Set i-th Bit}
\begin{minted}{cpp}
int setIthBit(int n, int i) { return n | (1 << i); }
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Swap Integer Variables}
\addcontentsline{toc}{subsection}{Swap Integer Variables}
\begin{minted}{cpp}
void swap(int &a, int &b) {
  a ^= b;
  b ^= a;
  a ^= b;
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{To Lower Case}
\addcontentsline{toc}{subsection}{To Lower Case}
\begin{minted}{cpp}
char lowerCase(char c) { return c | ' '; }
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{To Upper Case}
\addcontentsline{toc}{subsection}{To Upper Case}
\begin{minted}{cpp}
char upperCase(char c) { return c & '_'; }
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Toggle Case}
\addcontentsline{toc}{subsection}{Toggle Case}
\begin{minted}{cpp}
char toggleCase(char c) { return c ^ ' '; }
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Toggle i-th Bit}
\addcontentsline{toc}{subsection}{Toggle i-th Bit}
\begin{minted}{cpp}
int toggleIthBit(int n, int i) {
  return n ^ (1 << i);
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Two's Complement}
\addcontentsline{toc}{subsection}{Two's Complement}
\begin{minted}{cpp}
int twosComplement(int n) { return ~n + 1; }
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Unset i-th Bit}
\addcontentsline{toc}{subsection}{Unset i-th Bit}
\begin{minted}{cpp}
int unsetIthBit(int n, int i) {
  return n & (~(1 << i));
}
\end{minted}

\needspace{11\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{XOR From 1 To N}
\addcontentsline{toc}{subsection}{XOR From 1 To N}
\begin{minted}{cpp}
int xorToN(int n) {
  switch (n & 3) {
    case 0: return n;
    case 1: return 1;
    case 2: return n + 1;
    case 3: return 0;
  }
}
\end{minted}

\needspace{17\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Geometry}
\markboth{GEOMETRY}{}
\addcontentsline{toc}{section}{Geometry}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Data Structures}
\addcontentsline{toc}{subsection}{Data Structures}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Circle}
\addcontentsline{toc}{subsubsection}{Circle}
\begin{minted}{cpp}
// c = center, r = radius;
#include "Point.cpp"

struct Circle {
  Point c;
  ld r;
  Circle(Point c, ld r) : c(c), r(r) {}
};
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Point}
\addcontentsline{toc}{subsubsection}{Point}
\begin{minted}{cpp}
#include "../../Util/Double Comparisons With Given Precision.cpp"

const ld pi = acos(-1), inf = 1 << 30;
// (PointB - PointA) = vector from A to B.
struct Point {
  ld x, y;
  Point() : x(0), y(0) {}
  Point(ld x, ld y) : x(x), y(y) {}
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  Point operator+(const Point &p) const {
    return Point(x + p.x, y + p.y);
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  Point operator-(const Point &p) const {
    return Point(x - p.x, y - p.y);
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  Point operator*(const ld &k) const {
    return Point(x * k, y * k);
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  Point operator/(const ld &k) const {
    return Point(x / k, y / k);
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  bool operator==(const Point &p) const {
    return eq(x, p.x) && eq(y, p.y);
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  bool operator!=(const Point &p) const {
    return !(*this == p);
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  bool operator<(const Point &p) const {
    return eq(x, p.x) ? lt(y, p.y) : lt(x, p.x);
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  bool operator>(const Point &p) const {
    return eq(x, p.x) ? gt(y, p.y) : gt(x, p.x);
  }

  ld norm() const { return sqrt(x * x + y * y); }

  ld dot(const Point &p) { return x * p.x + y * p.y; }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  ld cross(const Point &p) {
    return x * p.y - y * p.x;
  }

  Point perpendicularLeft() { return Point(-y, x); }

  Point perpendicularRight() { return Point(y, -x); }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  Point rotate(ld deg) {
    ld rad = (deg * pi) / 180.0;
    return Point(x * cos(rad) - y * sin(rad),
                 x * sin(rad) + y * cos(rad));
  }

  Point unit() const { return (*this) / norm(); }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  Point projectOn(const Point &p) {
    return p.unit() * (dot(p) / p.norm());
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  ld angleWith(const Point &p) {
    ld x = dot(p) / norm() / p.norm();
    return acos(max(-1.0L, min(1.0L, x)));
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  bool isPerpendicularWith(const Point &p) {
    return dot(p);
  }
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
  // 1 p is on the left
  // -1 p is on the right
  // 0 p has our same direction
  ld positionOf(const Point &p) {
    short pos = cross(p);
    return lt(pos, 0) ? -1 : gt(pos, 0);
  }
};
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
istream &operator>>(istream &is, Point &p) {
  return is >> p.x >> p.y;
}
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
ostream &operator<<(ostream &os, const Point &p) {
  return os << "(" << p.x << ", " << p.y << ")";
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Intersection Points Of Segments In A Plane}
\addcontentsline{toc}{subsection}{Intersection Points Of Segments In A Plane}
\begin{minted}{cpp}
#include <bits/stdc++.h>
using namespace std;

#include "Data Structures/Point.cpp"

vector<Point> intersections(
    vector<pair<Point, Point>>& segs) {
    return {};
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Is Point In Line}
\addcontentsline{toc}{subsection}{Is Point In Line}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"

bool isPointInLine(Point& a, Point& b, Point& p) {
  return !(b - a).cross(p - a);
}
\end{minted}

\needspace{9\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Is Point In Segment}
\addcontentsline{toc}{subsection}{Is Point In Segment}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"

bool isPointInSegment(Point& a, Point& b, Point& p) {
  return !(b - a).cross(p - a) &&
         (a - p).dot(b - p) <= 0;
}
\end{minted}

\needspace{16\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Is Point Inside Polygon}
\addcontentsline{toc}{subsection}{Is Point Inside Polygon}
\begin{minted}{cpp}
// assumes the polygon is given counter-clockwise
// if point is exactly in edge, it's considered inside
// change "0 >" to "0 >=" to not consider it inside.
#include "Data Structures/Point.cpp"

bool isPointInPolygon(vector<Point> &ps, Point &p) {
  assert(ps.size() >= 3);
  for (int i = 0; i < ps.size(); i++)
    if (0 > (ps[(i + 1) % ps.size()] - ps[i])
                .positionOf(p - ps[i]))
      return false;
  return true;
}
\end{minted}

\needspace{14\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Line-Line Intersection}
\addcontentsline{toc}{subsection}{Line-Line Intersection}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"

pair<int, Point> llintersection(Point& a, Point& b,
                                Point& u, Point& v) {
  if ((b - a).cross(v - u))  // single point
    return {1, a + (b - a) * ((u - a).cross(v - u) /
                              (b - a).cross(v - u))};
  if ((b - a).cross(u - a))
    return {0, Point()};  // no points
  return {-1, Point()};   // infinity points
}
\end{minted}

\needspace{9\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Line-Segment Intersection}
\addcontentsline{toc}{subsection}{Line-Segment Intersection}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"

int sign(ld x) {
  if (x < 0) return -1;
  return x > 0;
}
\end{minted}
\vspace{-12pt}
\needspace{12\baselineskip}
\begin{minted}{cpp}
// line: a-b, segment: u-v
// 0: no point, 1: single point, -1: infinity points
pair<int, Point> lsintersection(Point& a, Point& b,
                                Point& u, Point& v) {
  if ((b - a).cross(v - u))
    return {sign((b - a).cross(u - a)) !=
                sign((b - a).cross(v - a)),
            a + (b - a) * ((u - a).cross(v - u) /
                           (b - a).cross(v - u))};
  if ((u - a).cross(b - a)) return {0, Point()};
  return {-1, Point()};
}
\end{minted}

\needspace{5\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Max Interval Overlap}
\addcontentsline{toc}{subsection}{Max Interval Overlap}
\begin{minted}{cpp}
typedef pair<double, double> Interval;
vector<Interval> maxIntervals;
\end{minted}
\vspace{-12pt}
\needspace{23\baselineskip}
\begin{minted}{cpp}
// O(N * lg(N))
int maxOverlap(vector<Interval> &arr) {
  maxIntervals.clear();
  map<double, int> m;
  int maxI = 0, curr = 0, isFirst = 1;
  double l = -1, r = -1;
  for (auto &i : arr) m[i.first]++, m[i.second + 0.1]--;
  for (auto &p : m) {
    curr += p.second;
    if (curr > maxI) maxI = curr, l = p.first;
    if (curr == maxI) r = p.first;
  }
  curr = 0;
  for (auto &p : m) {
    curr += p.second;
    if (curr == maxI && isFirst)
      l = p.first, isFirst = 0;
    if (curr < maxI && !isFirst)
      maxIntervals.push_back({l, p.first - 1}),
          isFirst = 1;
  }
  return maxI;
}
\end{minted}
\vspace{-12pt}
\needspace{23\baselineskip}
\begin{minted}{cpp}
// O(MaxPoint) maxPoint < vector::max_size
int maxOverlap(vector<Interval> &arr) {
  maxIntervals.clear();
  T maxPoint = 0;
  for (auto &i : arr)
    if (i.second > maxPoint) maxPoint = i.second;
  vector<int> x(maxPoint + 2);
  for (auto &i : arr) x[i.first]++, x[i.second + 1]--;
  int maxI = 0, curr = 0, isFirst = 1;
  T l = -1LL, r = -1LL;
  for (int i = 0; i < x.size(); i++) {
    curr += x[i];
    if (curr > maxI) maxI = curr;
  }
  curr = 0;
  for (int i = 0; i < x.size(); i++) {
    curr += x[i];
    if (curr == maxI && isFirst) l = i, isFirst = 0;
    if (curr < maxI && !isFirst)
      maxIntervals.push_back({l, i - 1}), isFirst = 1;
  }
  return maxI;
}
\end{minted}

\needspace{11\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Point Projection On Line}
\addcontentsline{toc}{subsection}{Point Projection On Line}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"

Point projectionOnLine(Point& a, Point& b, Point& p) {
  Point pr = a + (p - a).projectOn(b - a);
  if (abs(pr.x) < eps) pr.x = 0;
  if (abs(pr.y) < eps) pr.y = 0;
  return pr;
}
\end{minted}

\needspace{11\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Point Reflection On Line}
\addcontentsline{toc}{subsection}{Point Reflection On Line}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"

Point reflectionOnLine(Point& a, Point& b, Point& p) {
  Point r = a * 2 + (p - a).projectOn(b - a) * 2 - p;
  if (abs(r.x) < eps) r.x = 0;
  if (abs(r.y) < eps) r.y = 0;
  return r;
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Point-Line Distance}
\addcontentsline{toc}{subsection}{Point-Line Distance}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"

ld pointLineDist(Point& a, Point& b, Point& p) {
  return ((p - a).projectOn(b - a) - (p - a)).norm();
}
\end{minted}

\needspace{9\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Point-Line Distance (Signed)}
\addcontentsline{toc}{subsection}{Point-Line Distance (Signed)}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"
// ans > 0 p is on the left of a-b
// ans < 0 p is on the right of a-b
ld pointLineDist(Point& a, Point& b, Point& p) {
  return (b - a).cross(p - a) / (b - a).norm();
}
\end{minted}

\needspace{10\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Segment-Segment Intersection}
\addcontentsline{toc}{subsection}{Segment-Segment Intersection}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"

int sign(ld x) { return x < 0 ? -1 : x > 0; }

void swap(Point& a, Point& b) {
  swap(a.x, b.x), swap(a.y, b.y);
}
\end{minted}
\vspace{-12pt}
\needspace{17\baselineskip}
\begin{minted}{cpp}
// 0: no point, 1: single point, -1: infinity points
pair<int, Point> ssintersection(Point a, Point b,
                                Point u, Point v) {
  if ((b - a).cross(v - u))
    return {sign((b - a).cross(u - a)) !=
                    sign((b - a).cross(v - a)) &&
                sign((v - u).cross(a - u)) !=
                    sign((v - u).cross(b - u)),
            a + (b - a) * ((u - a).cross(v - u) /
                           (b - a).cross(v - u))};
  if ((b - a).cross(u - a)) return {0, Point()};
  if (a > b) swap(a, b);
  if (u > v) swap(u, v);
  if (a > u) swap(a, u), swap(b, v);
  if (u < b) return {-1, Point()};
  return {b == u, u};
}
\end{minted}

\needspace{11\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Sort Points Along Line With Direction}
\addcontentsline{toc}{subsection}{Sort Points Along Line With Direction}
\begin{minted}{cpp}
#include "Data Structures/Point.cpp"

void sortAlongLine(Point& a, Point& b,
                   vector<Point>& ps) {
  sort(ps.begin(), ps.end(), [&](Point& u, Point& v) {
    return u.dot(b - a) < v.dot(b - a);
  });
}
\end{minted}

\needspace{16\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Graphs}
\markboth{GRAPHS}{}
\addcontentsline{toc}{section}{Graphs}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Data Structures}
\addcontentsline{toc}{subsection}{Data Structures}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Union Find}
\addcontentsline{toc}{subsubsection}{Union Find}
\begin{minted}{cpp}
struct UnionFind {
  int n;
  vector<int> dad, size;

  UnionFind(int N) : n(N), dad(N), size(N, 1) {
    while (N--) dad[N] = N;
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg*(N))
  int root(int u) {
    if (dad[u] == u) return u;
    return dad[u] = root(dad[u]);
  }
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  // O(1)
  void join(int u, int v) {
    int Ru = root(u), Rv = root(v);
    if (Ru == Rv) return;
    if (size[Ru] > size[Rv]) swap(Ru, Rv);
    --n, dad[Ru] = Rv;
    size[Rv] += size[Ru];
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg*(N))
  bool areConnected(int u, int v) {
    return root(u) == root(v);
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  int getSize(int u) { return size[root(u)]; }

  int numberOfSets() { return n; }
};
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Union Find (Partially Persistent)}
\addcontentsline{toc}{subsubsection}{Union Find (Partially Persistent)}
\begin{minted}{cpp}
// jTime = join time, t = time
struct UnionFind {
  int Time = 0;
  vector<int> dad, size, jTime;

  UnionFind(int N) : dad(N), size(N, 1), jTime(N) {
    while (N--) dad[N] = N;
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  int root(int u, int t) {
    while (jTime[u] <= t && u != dad[u]) u = dad[u];
    return u;
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(1)
  void join(int u, int v, bool newTime = 1) {
    int Ru = root(u, Time), Rv = root(v, Time);
    if (newTime) Time++;
    if (Ru == Rv) return;
    if (size[Ru] > size[Rv]) swap(Ru, Rv);
    jTime[Ru] = Time;
    dad[Ru] = Rv;
    size[Rv] += size[Ru];
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  bool areConnected(int u, int v, int t) {
    return root(u, t) == root(v, t);
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  int getLastVersionSize(int u) {
    return size[root(u, Time)];
  }
\end{minted}
\vspace{-12pt}
\needspace{13\baselineskip}
\begin{minted}{cpp}
  // O(lg(Time) * lg(N))
  int joinTime(int u, int v) {
    int l = 0, r = Time, ans = -1;
    while (l <= r) {
      int mid = (l + r) >> 1;
      if (areConnected(u, v, mid))
        ans = mid, r = mid - 1;
      else
        l = mid + 1;
    }
    return ans;
  }
};
\end{minted}

\needspace{9\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Articulation Points And Bridges}
\addcontentsline{toc}{subsection}{Articulation Points And Bridges}
\begin{minted}{cpp}
// APB = articulation points and bridges
// Ap = Articulation Point
// br = bridges, p = parent
// disc = discovery time
// low = lowTime, ch = children
// nup = number of edges from u to p
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
typedef pair<int, int> Edge;
int Time;
vector<vector<int>> adj;
vector<int> disc, low, isAp;
vector<Edge> br;

void init(int N) { adj.assign(N, vector<int>()); }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v) {
  adj[u].push_back(v);
  adj[v].push_back(u);
}
\end{minted}
\vspace{-12pt}
\needspace{15\baselineskip}
\begin{minted}{cpp}
int dfsAPB(int u, int p) {
  int ch = 0, nup = 0;
  low[u] = disc[u] = ++Time;
  for (int &v : adj[u]) {
    if (v == p && !nup++) continue;
    if (!disc[v]) {
      ch++, dfsAPB(v, u);
      if (disc[u] <= low[v]) isAp[u]++;
      if (disc[u] < low[v]) br.push_back({u, v});
      low[u] = min(low[u], low[v]);
    } else
      low[u] = min(low[u], disc[v]);
  }
  return ch;
}
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
// O(N)
void APB() {
  br.clear();
  isAp = low = disc = vector<int>(adj.size());
  Time = 0;
  for (int u = 0; u < adj.size(); u++)
    if (!disc[u]) isAp[u] = dfsAPB(u, u) > 1;
}
\end{minted}

\needspace{7\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Connected Components}
\addcontentsline{toc}{subsection}{Connected Components}
\begin{minted}{cpp}
// comp = component
int compId;
vector<vector<int>> adj;
vector<int> getComp;
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj.assign(N, vector<int>());
  getComp.assign(N, -1);
  compId = 0;
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v) {
  adj[u].push_back(v);
  adj[v].push_back(u);
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
void dfsCC(int u, vector<int> &comp) {
  if (getComp[u] > -1) return;
  getComp[u] = compId;
  comp.push_back(u);
  for (auto &v : adj[u]) dfsCC(v, comp);
}
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
// O(N)
vector<vector<int>> connectedComponents() {
  vector<vector<int>> comps;
  for (int u = 0; u < adj.size(); u++) {
    vector<int> comp;
    dfsCC(u, comp);
    if (!comp.empty())
      comps.push_back(comp), compId++;
  }
  return comps;
}
\end{minted}

\needspace{7\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Flood Fill}
\addcontentsline{toc}{subsection}{Flood Fill}
\begin{minted}{cpp}
int n, m, oldColor = 0, color = 1;
vector<vector<int>> mat;
vector<vector<int>> movs = {
    {1, 0}, {0, 1}, {-1, 0}, {0, -1}};
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
void floodFill(int i, int j) {
  if (i >= mat.size() || i < 0 ||
      j >= mat[i].size() || j < 0 ||
      mat[i][j] != oldColor)
    return;
  mat[i][j] = color;
  for (auto move : movs)
    floodFill(i + move[1], j + move[0]);
}
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
void floodFill() {
  for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
      if (mat[i][j] == oldColor) floodFill(i, j);
}
\end{minted}

\needspace{9\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Heavy Light Decomposition}
\addcontentsline{toc}{subsection}{Heavy Light Decomposition}
\begin{minted}{cpp}
// p = parent;
#include "../Ranges/Data Structures/Segment Tree Lazy Propagation.cpp"
typedef int T;
vector<vector<int>> adj;
vector<int> p, heavy, depth, root, stPos, vals;
SegmentTree<T> st(0, 0);
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
void init(int n) {
  adj.assign(n, vector<int>());
  heavy.assign(n, -1);
  vals.assign(n, 0);
  p = root = stPos = depth = heavy;
  st = SegmentTree<T>(n, 0);
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v, T val) {
  adj[u].push_back(v);
  p[v] = u, vals[v] = val;
}

T F(T a, T b) { return a + b; }
\end{minted}
\vspace{-12pt}
\needspace{13\baselineskip}
\begin{minted}{cpp}
// O(N)
int dfs(int u) {
  int size = 1, maxSubtree = 0;
  for (int &v : adj[u]) {
    depth[v] = depth[u] + 1;
    int subtree = dfs(v);
    if (subtree > maxSubtree)
      heavy[u] = v, maxSubtree = subtree;
    size += subtree;
  }
  return size;
}
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
// O(N)
void initHeavyLight() {
  for (int i = 0; i < adj.size(); i++)
    if (p[i] < 0) dfs(i);
  for (int i = 0, pos = 0; i < adj.size(); i++)
    if (p[i] < 0 || heavy[p[i]] != i)
      for (int j = i; ~j; j = heavy[j])
        st[stPos[j] = pos++] = vals[j], root[j] = i;
  st.build();
}
\end{minted}
\vspace{-12pt}
\needspace{13\baselineskip}
\begin{minted}{cpp}
// O(lg^2 (N))
template <class Op>
void processPath(int u, int v, Op op) {
  for (; root[u] != root[v]; v = p[root[v]]) {
    if (depth[root[u]] > depth[root[v]]) swap(u, v);
    op(stPos[root[v]], stPos[v]);
  }
  if (depth[u] > depth[v]) swap(u, v);
  // for values on edges
  if (u != v) op(stPos[u] + 1, stPos[v]);
  // for values on nodes
  // op(stPos[u], stPos[v]);
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
// O(lg^2 (N))
void update(int u, int v, T val) {
  processPath(u, v, [&val](int l, int r) {
    st.update(l, r, val);
  });
}
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
// O(lg^2 (N))
T query(int u, int v) {
  T ans = T();
  processPath(u, v, [&ans](int l, int r) {
    ans = F(ans, st.query(l, r));
  });
  return ans;
}
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Is Bipartite}
\addcontentsline{toc}{subsection}{Is Bipartite}
\begin{minted}{cpp}
vector<vector<int>> adj;

void init(int N) { adj.assign(N, vector<int>()); }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v) {
  adj[u].push_back(v);
  adj[v].push_back(u);
}
\end{minted}
\vspace{-12pt}
\needspace{20\baselineskip}
\begin{minted}{cpp}
// O(N)
bool isBipartite() {
  vector<int> color(adj.size(), -1);
  for (int s = 0; s < adj.size(); s++) {
    if (color[s] > -1) continue;
    color[s] = 0;
    queue<int> q;
    q.push(s);
    while (!q.empty()) {
      int u = q.front();
      q.pop();
      for (int &v : adj[u]) {
        if (color[v] < 0)
          q.push(v), color[v] = !color[u];
        if (color[v] == color[u]) return false;
      }
    }
  }
  return true;
}
\end{minted}

\needspace{10\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Lowest Common Ancestor}
\addcontentsline{toc}{subsection}{Lowest Common Ancestor}
\begin{minted}{cpp}
// p = parent
#include "../Ranges/Data Structures/Sparse Table.cpp"
typedef pair<int, int> pairii;
vector<int> firstPos;
vector<pair<int, int>> tour;
vector<vector<int>> adj;
SparseTable<pairii> st;

void init(int N) { adj.assign(N, vector<int>()); }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v) {
  adj[u].push_back(v);
  adj[v].push_back(u);
}
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
// O(N)
void eulerTour(int u, int p, int h) {
  firstPos[u] = tour.size();
  tour.push_back({h, u});
  for (int v : adj[u])
    if (v != p) {
      eulerTour(v, u, h + 1);
      tour.push_back({h, u});
    }
}
\end{minted}
\vspace{-12pt}
\needspace{11\baselineskip}
\begin{minted}{cpp}
// O(N * lg(N))
void preprocess() {
  tour.clear();
  firstPos.assign(adj.size(), -1);
  vector<int> roots = {0};
  for (auto &root : roots) eulerTour(root, -1, 0);
  st = SparseTable<pairii>(
      tour, [](pairii a, pairii b) {
        return a.first < b.first ? a : b;
      });
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
// O(1)
int lca(int u, int v) {
  int l = min(firstPos[u], firstPos[v]);
  int r = max(firstPos[u], firstPos[v]);
  return st.query(l, r).second;
}
\end{minted}

\needspace{11\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Minimum Spanning Tree (Kruskal)}
\addcontentsline{toc}{subsection}{Minimum Spanning Tree (Kruskal)}
\begin{minted}{cpp}
// N = number of nodes, Wedge = Weighted Edge
#include "Data Structures/Union Find.cpp"
typedef int T;
typedef pair<int, int> Edge;
typedef pair<T, Edge> Wedge;
vector<Wedge> Wedges;
vector<Wedge> mst;
UnionFind uf(0);
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  mst.clear();
  Wedges.clear();
  uf = UnionFind(N);
}
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v, T w) {
  Wedges.push_back({w, {u, v}});
}
\end{minted}
\vspace{-12pt}
\needspace{13\baselineskip}
\begin{minted}{cpp}
T kruskal() {
  T cost = 0;
  sort(Wedges.begin(), Wedges.end());
  // reverse(Wedges.begin(), Wedges.end());
  for (Wedge &wedge : Wedges) {
    int u = wedge.second.first,
        v = wedge.second.second;
    if (!uf.areConnected(u, v))
      uf.join(u, v), mst.push_back(wedge),
          cost += wedge.first;
  }
  return cost;
}
\end{minted}

\needspace{15\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Minimum Spanning Tree (Prim)}
\addcontentsline{toc}{subsection}{Minimum Spanning Tree (Prim)}
\begin{minted}{cpp}
// st = spanning tree, p = parent
// vis = visited, dist = distance
typedef int T;
typedef pair<int, int> Edge;
typedef pair<T, Edge> Wedge;
typedef pair<T, int> DistNode;
long long int inf = (1ll << 62) - 1;
vector<vector<int>> adj;
unordered_map<int, unordered_map<int, T>> weight;
vector<int> p, vis;
vector<T> dist;
vector<vector<Wedge>> msts;
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj.assign(N, vector<int>());
  p.assign(N, 0);
  vis.assign(N, 0);
  dist.assign(N, inf);
  weight.clear();
  msts.clear();
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v, T w) {
  adj[u].push_back(v);
  weight[u][v] = w;
  adj[v].push_back(u);
  weight[v][u] = w;
}
\end{minted}
\vspace{-12pt}
\needspace{25\baselineskip}
\begin{minted}{cpp}
// ~ O(E * log(V))
T prim(int s) {
  vector<Wedge> mst;
  vector<T> dist(adj.size(), inf);
  priority_queue<DistNode> q;
  T cost = dist[s] = 0;
  q.push({0, s});
  while (q.size()) {
    pair<int, int> aux = q.top();
    int u = aux.second;
    q.pop();
    if (dist[u] < -aux.first) continue;
    vis[u] = 1, cost += dist[u];
    mst.push_back({dist[u], {p[u], u}});
    for (int &v : adj[u]) {
      T w = weight[u][v];
      if (!vis[v] && w < dist[v])
        q.push({-(dist[v] = w), v});
    }
  }
  msts.push_back(
      vector<Wedge>(mst.begin() + 1, mst.end()));
  return cost;
}
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
// O(V + E * log(V))
T prim() {
  T cost = 0;
  map<int, T> q;
  for (int i = 0; i < adj.size(); i++)
    if (!vis[i]) cost += prim(i);
  return cost;
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Strongly Connected Components}
\addcontentsline{toc}{subsection}{Strongly Connected Components}
\begin{minted}{cpp}
// tv = top value from stack
// sccs = strongly connected components
// scc = strongly connected component
// disc = discovery time, low = low time
// s = stack, top = top index of the stack
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
int Time, top;
vector<vector<int>> adj, sccs;
vector<int> disc, low, s;

void init(int N) { adj.assign(N, vector<int>()); }

void addEdge(int u, int v) { adj[u].push_back(v); }
\end{minted}
\vspace{-12pt}
\needspace{17\baselineskip}
\begin{minted}{cpp}
void dfsSCCS(int u) {
  if (disc[u]) return;
  low[u] = disc[u] = ++Time;
  s[++top] = u;
  for (int &v : adj[u])
    dfsSCCS(v), low[u] = min(low[u], low[v]);
  if (disc[u] == low[u]) {
    vector<int> scc;
    while (true) {
      int tv = s[top--];
      scc.push_back(tv);
      low[tv] = adj.size();
      if (tv == u) break;
    }
    sccs.push_back(scc);
  }
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
// O(N)
void SCCS() {
  s = low = disc = vector<int>(adj.size());
  Time = 0, top = -1, sccs.clear();
  for (int u = 0; u < adj.size(); u++) dfsSCCS(u);
}
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Topological Sort}
\addcontentsline{toc}{subsection}{Topological Sort}
\begin{minted}{cpp}
// vis = visited
vector<vector<int>> adj;
vector<int> vis, toposorted;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj.assign(N, vector<int>());
  vis.assign(N, 0), toposorted.clear();
}

void addEdge(int u, int v) { adj[u].push_back(v); }
\end{minted}
\vspace{-12pt}
\needspace{12\baselineskip}
\begin{minted}{cpp}
// returns false if there is a cycle
// O(E)
bool toposort(int u) {
  vis[u] = 1;
  for (auto &v : adj[u])
    if (v != u && vis[v] != 2 &&
        (vis[v] || !toposort(v)))
      return false;
  vis[u] = 2;
  toposorted.push_back(u);
  return true;
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
// O(V + E)
bool toposort() {
  for (int u = 0; u < adj.size(); u++)
    if (!vis[u] && !toposort(u)) return false;
  return true;
}
\end{minted}

\needspace{7\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Topological Sort (All possible sorts)}
\addcontentsline{toc}{subsection}{Topological Sort (All possible sorts)}
\begin{minted}{cpp}
// indeg0 = indegree 0
vector<int> vis, indegree, path;
vector<vector<int>> adj, toposorts;
deque<int> indeg0;
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
void init(int n) {
  adj.assign(n, vector<int>());
  vis.assign(n, 0);
  indegree = vis;
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v) {
  adj[u].push_back(v);
  indegree[v]++;
}
\end{minted}
\vspace{-12pt}
\needspace{19\baselineskip}
\begin{minted}{cpp}
// O(V!)
void dfs() {
  for (int i = 0; i < indeg0.size(); i++) {
    int u = indeg0.front();
    indeg0.pop_front();
    path.push_back(u);
    for (auto &v : adj[u])
      if (!--indegree[v]) indeg0.push_back(v);
    if (!indeg0.size()) toposorts.push_back(path);
    dfs();
    for (int v = adj[u].size() - 1; ~v; v--) {
      indegree[adj[u][v]]++;
      if (indeg0.back() == adj[u][v])
        indeg0.pop_back();
    }
    indeg0.push_back(u);
    path.pop_back();
  }
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
// O(V + V!)
void allToposorts() {
  for (int u = 0; u < adj.size(); u++)
    if (!indegree[u]) indeg0.push_back(u);
  dfs();
}
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Topological Sort (lowest lexicographically)}
\addcontentsline{toc}{subsection}{Topological Sort (lowest lexicographically)}
\begin{minted}{cpp}
// indeg0 = indegree 0
vector<vector<int>> adj;
vector<int> indegree, toposorted;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int n) {
  adj.assign(n, vector<int>());
  indegree.assign(n, 0), toposorted.clear();
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v) {
  adj[u].push_back(v);
  indegree[v]++;
}
\end{minted}
\vspace{-12pt}
\needspace{16\baselineskip}
\begin{minted}{cpp}
// returns false if there is a cycle
// O(V * lg(V) + E)
bool toposort() {
  set<int> indeg0;
  for (int u = 0; u < adj.size(); u++)
    if (!indegree[u]) indeg0.insert(u);
  int cnt = 0;
  while (indeg0.size()) {
    auto u = indeg0.begin();
    toposorted.push_back(*u);
    for (auto& v : adj[*u])
      if (!--indegree[v]) indeg0.insert(v);
    cnt++, indeg0.erase(u);
  }
  return cnt < adj.size() ? false : true;
}
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Tree Diameter (Longest Path Between 2 Nodes)}
\addcontentsline{toc}{subsection}{Tree Diameter (Longest Path Between 2 Nodes)}
\begin{minted}{cpp}
int inf = (1 << 30) - 1;
vector<vector<int>> adj;

void init(int N) { adj.assign(N, vector<int>()); }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v) {
  adj[u].push_back(v);
  adj[v].push_back(u);
}
\end{minted}
\vspace{-12pt}
\needspace{16\baselineskip}
\begin{minted}{cpp}
int bfs(int u) {
  vector<int> dist(adj.size(), inf);
  queue<int> q;
  q.push(u), dist[u] = 0;
  while (q.size()) {
    int u = q.front();
    q.pop();
    for (int& v : adj[u])
      if (dist[v] == inf)
        q.push(v), dist[v] = dist[u] + 1;
  }
  int node, maxx = -inf;
  for (int u = 0; u < adj.size(); u++)
    if (dist[u] > maxx) maxx = dist[u], node = u;
  return node;
}
\end{minted}
\vspace{-12pt}
\needspace{16\baselineskip}
\begin{minted}{cpp}
vector<int> diameter() {
  int u = bfs(0), v = bfs(u);
  vector<int> path = {v}, vis(adj.size());
  function<bool(int)> dfs = [&](int a) {
    if (a == v) return true;
    vis[a] = 1;
    for (int& b : adj[a]) {
      if (vis[b] || !dfs(b)) continue;
      path.push_back(a);
      return true;
    }
    return false;
  };
  dfs(u);
  return path;
}
\end{minted}

\needspace{10\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Cycles}
\addcontentsline{toc}{subsection}{Cycles}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Get Some Cycles}
\addcontentsline{toc}{subsubsection}{Get Some Cycles}
\begin{minted}{cpp}
// at least detects one cycle per component
vector<vector<int>> adj, cycles;
vector<int> vis, cycle;
bool flag = false, isDirected = false;
int root = -1;
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj.assign(N, vector<int>());
  vis.assign(N, 0);
  cycles.clear();
  root = -1, flag = false;
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v) {
  adj[u].push_back(v);
  if (!isDirected) adj[v].push_back(u);
}
\end{minted}
\vspace{-12pt}
\needspace{22\baselineskip}
\begin{minted}{cpp}
// O(N)
bool hasCycle(int u, int prev) {
  vis[u] = 1;
  for (auto &v : adj[u]) {
    if (v == u || vis[v] == 2 ||
        (!isDirected && v == prev))
      continue;
    if (flag) {
      if (!vis[v]) hasCycle(v, u);
      continue;
    }
    if (vis[v] || hasCycle(v, u)) {
      if (root == -1) root = v, flag = true;
      cycle.push_back(u);
      if (root == u)
        flag = false, root = -1,
        cycles.push_back(cycle), cycle.clear();
    }
  }
  vis[u] = 2;
  return flag;
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
// O(N)
bool hasCycle() {
  for (int u = 0; u < adj.size(); u++)
    if (!vis[u]) cycle.clear(), hasCycle(u, -1);
  return cycles.size() > 0;
}
\end{minted}

\needspace{5\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Has Cycle}
\addcontentsline{toc}{subsubsection}{Has Cycle}
\begin{minted}{cpp}
vector<vector<int>> adj;
vector<int> vis;
bool isDirected = false;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj.assign(N, vector<int>());
  vis.assign(N, 0);
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdge(int u, int v) {
  adj[u].push_back(v);
  if (!isDirected) adj[v].push_back(u);
}
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
bool hasCycle(int u, int prev) {
  vis[u] = 1;
  for (auto &v : adj[u])
    if (v != u && vis[v] != 2 &&
        (isDirected || v != prev) &&
        (vis[v] || hasCycle(v, u)))
      return true;
  vis[u] = 2;
  return false;
}
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
// O(N)
bool hasCycle() {
  for (int u = 0; u < adj.size(); u++)
    if (!vis[u] && hasCycle(u, -1)) return true;
}
\end{minted}

\needspace{12\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Flow}
\addcontentsline{toc}{subsection}{Flow}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Max Flow Min Cut Dinic}
\addcontentsline{toc}{subsubsection}{Max Flow Min Cut Dinic}
\begin{minted}{cpp}
// level[a] = level in graph of node a
// pathMinCap = capacity bottleneck for a path (s->t)
// icap = initial capacity, f[u] = flow of u
// adj[u][i] = edge from u to v = adj[u][i]
// cap[u][i] = capacity of edge u->adj[u][i]
// rev[u][i] = index of u in adj[v]
// rev is used to find the corresponding reverse edge
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
typedef int T;
const T inf = 1 << 30;
vector<vector<int>> adj, rev;
vector<vector<T>> cap;
vector<int> level;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj = rev = vector<vector<int>>(N);
  cap = vector<vector<T>>(N);
}
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
// Assumes Directed Graph
void addEdge(int u, int v, T icap) {
  rev[u].push_back(adj[v].size());
  rev[v].push_back(adj[u].size());
  adj[u].push_back(v), adj[v].push_back(u);
  cap[u].push_back(icap), cap[v].push_back(0);
}
\end{minted}
\vspace{-12pt}
\needspace{17\baselineskip}
\begin{minted}{cpp}
bool levelGraph(int s, int t) {
  level.assign(adj.size(), 0);
  queue<int> q;
  level[s] = 1, q.push(s);
  while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int i = 0; i < adj[u].size(); i++) {
      int v = adj[u][i];
      if (!level[v] && cap[u][i]) {
        q.push(v);
        level[v] = level[u] + 1;
      }
    }
  }
  return level[t];
}
\end{minted}
\vspace{-12pt}
\needspace{14\baselineskip}
\begin{minted}{cpp}
T blockingFlow(int u, int t, T pathMinCap) {
  if (u == t) return pathMinCap;
  for (int i = 0; i < adj[u].size(); i++) {
    int v = adj[u][i];
    if (level[v] == (level[u] + 1) && cap[u][i])
      if (T pathMaxFlow = blockingFlow(
          v, t, min(pathMinCap, cap[u][i]))) {
        cap[u][i] -= pathMaxFlow;
        cap[v][rev[u][i]] += pathMaxFlow;
        return pathMaxFlow;
      }
  }
  return 0;
}
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
// O(V^2 * E)
T maxFlowMinCut(int s, int t) {
  if (s == t) return inf;
  T maxFlow = 0;
  while (levelGraph(s, t))
    while (T flow = blockingFlow(s, t, inf))
      maxFlow += flow;
  return maxFlow;
}
\end{minted}

\needspace{8\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Max Flow Min Cut Edmonds-Karp}
\addcontentsline{toc}{subsubsection}{Max Flow Min Cut Edmonds-Karp}
\begin{minted}{cpp}
// icap = initial capacity, f[u] = flow of u
// adj[u][i] = edge from u to v = adj[u][i]
// cap[u][i] = capacity of edge u->adj[u][i]
// rev[u][i] = index of u in adj[v]
// rev is used to find the corresponding reverse edge
// s = source, t = target
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
typedef int T;
vector<vector<int>> adj, rev;
vector<vector<T>> cap;
const T inf = 1 << 30;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj = rev = vector<vector<int>>(N);
  cap = vector<vector<T>>(N);
}
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
// Assumes Directed Graph
void addEdge(int u, int v, T icap) {
  rev[u].push_back(adj[v].size());
  rev[v].push_back(adj[u].size());
  adj[u].push_back(v), adj[v].push_back(u);
  cap[u].push_back(icap), cap[v].push_back(0);
}
\end{minted}
\vspace{-12pt}
\needspace{29\baselineskip}
\begin{minted}{cpp}
// O(V * E^2)
T maxFlowMinCut(int s, int t) {
  if (s == t) return inf;
  T maxFlow = 0;
  vector<T> f(adj.size());
  while (true) {
    vector<pair<int, int>> dad(adj.size(), {-1, -1});
    queue<int> q;
    q.push(s), f[s] = inf;
    while (q.size() && dad[t].first == -1) {
      int u = q.front(); q.pop();
      for (int i = 0; i < adj[u].size(); i++) {
        int v = adj[u][i];
        if (dad[v].first == -1 && cap[u][i]) {
          f[v] = min(f[u], cap[u][i]);
          q.push(v), dad[v] = {u, i};
        }
      }
    }
    if (dad[t].first == -1) break;
    maxFlow += f[t];
    for (int v = t; v != s; v = dad[v].first) {
      auto u = dad[v];
      cap[u.first][u.second] -= f[t];
      cap[v][rev[u.first][u.second]] += f[t];
    }
  }
  return maxFlow;
}
\end{minted}

\needspace{2\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Maximum Bipartite Matching}
\addcontentsline{toc}{subsubsection}{Maximum Bipartite Matching}
\begin{minted}{cpp}
// mbm = maximum bipartite matching
#include "Max Flow Min Cut Dinic.cpp"
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void addEdgeMBM(int u, int v) {
  addEdge(u += 2, v += 2, 1);
  addEdge(0, u, 1);
  addEdge(v, 1, 1);
}
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
// O(V^2 * E)
T mbm() { return maxFlowMinCut(0, 1); }
\end{minted}

\needspace{9\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Minimum Cost Flow}
\addcontentsline{toc}{subsubsection}{Minimum Cost Flow}
\begin{minted}{cpp}
// icost = initial cost, icap = initial capacity
// adj[u][i] = edge from u to v = adj[u][i]
// cap[u][i] = capacity of edge u->adj[u][i]
// cost[u][i] = cost of edge u->adj[u][i]
// rev[u][i] = index of u in adj[v], s = source
// rev is used to find the corresponding reverse edge
// d = distance vector, f[u] = flow of u, t = target
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
typedef int T;
const T inf = 1 << 30;
vector<vector<int>> adj, rev;
vector<vector<T>> cap, cost;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj = rev = vector<vector<int>>(N);
  cap = cost = vector<vector<T>>(N);
}
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
// Assumes Directed Graph
void addEdge(int u, int v, T icap, T icost) {
  rev[u].push_back(adj[v].size());
  rev[v].push_back(adj[u].size());
  adj[u].push_back(v), adj[v].push_back(u);
  cap[u].push_back(icap), cap[v].push_back(0);
  cost[u].push_back(icost), cost[v].push_back(-icost);
}
\end{minted}
\vspace{-12pt}
\needspace{35\baselineskip}
\begin{minted}{cpp}
// O(V^2 * E^2)
pair<T, T> minCostFlow(int s, int t, int k = inf) {
  if (s == t) return {k, 0};
  T flow = 0, fcost = 0;
  vector<int> inqueue(adj.size());
  vector<T> f(adj.size());
  while (flow < k) {
    vector<pair<int, int>> dad(adj.size(), {-1, -1});
    vector<T> d(adj.size(), inf);
    vector<int> its(adj.size());
    queue<int> q;
    q.push(s), d[s] = 0, its[s] = 1, f[s] = k - flow;
    while (q.size()) {
      int u = q.front();
      q.pop(), inqueue[u] = 0;
      for (int i = 0; i < adj[u].size(); i++) {
        int v = adj[u][i];
        T dist = d[u] + cost[u][i];
        if (dist < d[v] && cap[u][i]) {
          d[v] = dist, dad[v] = {u, i};
          f[v] = min(f[u], cap[u][i]);
          if (!inqueue[v]++) q.push(v), its[v]++;
          if (its[v] == adj.size()) return {-1, -1};
        }
      }
    }
    if (dad[t].first == -1) break;
    flow += f[t], fcost += f[t] * d[t];
    for (int v = t; v != s; v = dad[v].first) {
      auto u = dad[v];
      cap[u.first][u.second] -= f[t];
      cap[v][rev[u.first][u.second]] += f[t];
    }
  }
  return {flow, fcost};
}
\end{minted}

\needspace{10\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Shortest Paths}
\addcontentsline{toc}{subsection}{Shortest Paths}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{0 - 1 BFS}
\addcontentsline{toc}{subsubsection}{0 - 1 BFS}
\begin{minted}{cpp}
// s = source
typedef int T; // sum of costs might overflow
const T inf = 1 << 30;
vector<vector<int>> adj;
vector<vector<T>> cost;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj.assign(N, vector<int>());
  cost.assign(N, vector<T>());
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
// Assumes Directed Graph
void addEdge(int u, int v, T c) {
  adj[u].push_back(v), cost[u].push_back(c);
}
\end{minted}
\vspace{-12pt}
\needspace{17\baselineskip}
\begin{minted}{cpp}
// O(E)
vector<T> sssp01(int s) {
  vector<T> dist(adj.size(), inf);
  deque<int> q;
  dist[s] = 0, q.push_front(s);
  while (q.size()) {
    int u = q.front(); q.pop_front();
    for (int i = 0; i < adj[u].size(); i++) {
      int v = adj[u][i];
      T d = dist[u] + cost[u][i];
      if (d < dist[v])
        cost[u][i] ? q.push_back(v)
                     : q.push_front(v);
    }
  }
  return dist;
}
\end{minted}

\needspace{8\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Bellman Ford}
\addcontentsline{toc}{subsubsection}{Bellman Ford}
\begin{minted}{cpp}
// s = source
// returns {} if there is a negative cost cycle
typedef int T;  // sum of costs might overflow
const T inf = 1 << 30;
vector<vector<int>> adj;
vector<vector<T>> cost;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj = vector<vector<int>>(N);
  cost = vector<vector<T>>(N);
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
// Assumes Directed Graph
void addEdge(int u, int v, T c) {
  adj[u].push_back(v), cost[u].push_back(c);
}
\end{minted}
\vspace{-12pt}
\needspace{16\baselineskip}
\begin{minted}{cpp}
// O(V * E)
vector<T> bellmanFord(int s) {
  vector<T> dist(adj.size(), inf);
  dist[s] = 0;
  for (int i = 1; i <= adj.size(); i++)
    for (int u = 0; u < adj.size(); u++)
      for (int i = 0; i < adj[u].size(); i++) {
        int v = adj[u][i];
        T d = dist[u] + cost[u][i];
        if (dist[u] != inf && d < dist[v]) {
          if (i == adj.size()) return {};
          dist[v] = d;
        }
      }
  return dist;
}
\end{minted}

\needspace{8\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Bellman Ford Fast}
\addcontentsline{toc}{subsubsection}{Bellman Ford Fast}
\begin{minted}{cpp}
// s = source
// returns {} if there is a negative cost cycle
typedef int T;  // sum of costs might overflow
const T inf = 1 << 30;
vector<vector<int>> adj;
vector<vector<T>> cost;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj = vector<vector<int>>(N);
  cost = vector<vector<T>>(N);
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
// Assumes Directed Graph
void addEdge(int u, int v, T c) {
  adj[u].push_back(v), cost[u].push_back(c);
}
\end{minted}
\vspace{-12pt}
\needspace{20\baselineskip}
\begin{minted}{cpp}
// O(V * E)
vector<T> bellmanFordFast(int s) {
  vector<T> dist(adj.size(), inf);
  vector<int> its(adj.size()), inqueue(adj.size());
  queue<int> q;
  q.push(s), dist[s] = 0, its[s] = 1;
  while (!q.empty()) {
    int u = q.front(); q.pop(), inqueue[u] = 0;
    for (int i = 0; i < adj[u].size(); i++) {
      int v = adj[u][i];
      T d = dist[u] + cost[u][i];
      if (d < dist[v]) {
        dist[v] = d;
        if (!inqueue[v]++) q.push(v), its[v]++;
        if (its[v] == adj.size()) return {};
      }
    }
  }
  return dist;
}
\end{minted}

\needspace{7\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Dijkstra}
\addcontentsline{toc}{subsubsection}{Dijkstra}
\begin{minted}{cpp}
// s = source
typedef int T;  // sum of costs might overflow
typedef pair<T, int> DistNode;
const T inf = 1 << 30;
vector<vector<int>> adj;
vector<vector<T>> cost;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void init(int N) {
  adj = vector<vector<int>>(N);
  cost = vector<vector<T>>(N);
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
// Assumes Directed Graph
void addEdge(int u, int v, T c) {
  adj[u].push_back(v), cost[u].push_back(c);
}
\end{minted}
\vspace{-12pt}
\needspace{17\baselineskip}
\begin{minted}{cpp}
// ~ O(E * lg(V))
vector<T> dijkstra(int s) {
  vector<T> dist(adj.size(), inf);
  priority_queue<DistNode> q;
  q.push({0, s}), dist[s] = 0;
  while (q.size()) {
    DistNode top = q.top(); q.pop();
    int u = top.second;
    if (dist[u] < -top.first) continue;
    for (int i = 0; i < adj[u].size(); i++) {
      int v = adj[u][i];
      T d = dist[u] + cost[u][i];
      if (d < dist[v]) q.push({-(dist[v] = d), v});
    }
  }
  return dist;
}
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Floyd Warshall}
\addcontentsline{toc}{subsubsection}{Floyd Warshall}
\begin{minted}{cpp}
// d = distance
typedef int T;  // sum of costs might overflow
const T inf = 1 << 30;
vector<vector<T>> d;

void init(int n) {
  d.assign(n, vector<T>(n, inf));
  for (int i = 0; i < n; i++) d[i][i] = 0;
}
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
// Assumes Directed Graph
void addEdge(int u, int v, T c) { d[u][v] = c; }
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
// O(V^3)
void floydwarshall() {
  for (int k = 0; k < d.size(); k++)
    for (int u = 0; u < d.size(); u++)
      for (int v = 0; v < d.size(); v++)
        d[u][v] = min(d[u][v], d[u][k] + d[k][v]);
}
\end{minted}

\needspace{12\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Shortest Path in Directed Acyclic Graph}
\addcontentsline{toc}{subsubsection}{Shortest Path in Directed Acyclic Graph}
\begin{minted}{cpp}
// s = source
#include "../Topological Sort.cpp"
typedef int T; // sum of costs might overflow
const T inf = 1 << 30;
vector<vector<T>> cost;

void init(int N) {
  init(N); // toposort init()
  cost = vector<vector<T>>(N);
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
// Assumes Directed Graph
void addEdge(int u, int v, T c) {
  adj[u].push_back(v), cost[u].push_back(c);
}
\end{minted}
\vspace{-12pt}
\needspace{15\baselineskip}
\begin{minted}{cpp}
// O(N)
vector<T> dagsssp(int s) {
  vector<T> dist(adj.size(), inf);
  dist[s] = 0, toposort(s);
  while (toposorted.size()) {
    int u = toposorted.back();
    toposorted.pop_back();
    for (int i = 0; i < adj[u].size(); i++) {
      int v = adj[u][i];
      T d = dist[u] + cost[u][i];
      if (d < dist[v]) dist[v] = d;
    }
  }
  return dist;
}
\end{minted}

\needspace{13\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Maths}
\markboth{MATHS}{}
\addcontentsline{toc}{section}{Maths}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Data Structures}
\addcontentsline{toc}{subsection}{Data Structures}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Matrix}
\addcontentsline{toc}{subsubsection}{Matrix}
\begin{minted}{cpp}
template <class T>
struct Matrix {
  int rows, cols;
  vector<vector<T>> m;
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  Matrix(int r, int c) : rows(r), cols(c) {
    m.assign(r, vector<T>(c));
  }
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
  Matrix(const vector<vector<T>>& b)
      : rows(b.size()), cols(b[0].size()), m(b) {}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  Matrix(int n) {
    m.assign(n, vector<T>(n));
    while (n--) m[n][n] = 1;
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  vector<T>& operator[](int i) const {
    return const_cast<Matrix*>(this)->m[i];
  }
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  // O(N * M)
  Matrix operator+(const Matrix& b) {
    Matrix ans(rows, cols);
    for (int i = 0; i < rows; i++)
      for (int j = 0; j < m[i].size(); j++)
        ans[i][j] = m[i][j] + b[i][j];
    return ans;
  }
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  // O(N * M)
  Matrix operator-(const Matrix& b) {
    Matrix ans(rows, cols);
    for (int i = 0; i < rows; i++)
      for (int j = 0; j < m[i].size(); j++)
        ans[i][j] = m[i][j] - b[i][j];
    return ans;
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(N^3)
  Matrix operator*(const Matrix& b) {
    if (cols != b.rows) return Matrix(0, 0);
    Matrix ans(rows, b.cols);
    for (int i = 0; i < rows; i++)
      for (int j = 0; j < b[i].size(); j++)
        for (int k = 0; k < b.rows; k++)
          ans[i][j] += m[i][k] * b[k][j];
    return ans;
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  Matrix& operator+=(const Matrix& b) {
    return *this = *this + b;
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  Matrix& operator-=(const Matrix& b) {
    return *this = *this - b;
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  Matrix& operator*=(const Matrix& b) {
    return *this = *this * b;
  }
};
\end{minted}

\needspace{14\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Combinatorics}
\addcontentsline{toc}{subsection}{Combinatorics}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Binomial Coefficient}
\addcontentsline{toc}{subsubsection}{Binomial Coefficient}
\begin{minted}{cpp}
typedef long long int li;

// O(k)
li nCk(li n, int k) {
  double ans = 1;
  for (int i = 1; i <= k; i++)
    ans = ans * (n - k + i) / i;
  return (li)(ans + 0.01);
}
\end{minted}

\needspace{14\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Binomial Coefficient (Pascal's Triangle)}
\addcontentsline{toc}{subsubsection}{Binomial Coefficient (Pascal's Triangle)}
\begin{minted}{cpp}
typedef long long int li;

vector<vector<li>> nCk(int maxN) {
  vector<vector<li>> c(++maxN, vector<li>(maxN));
  c[0][0] = 1;
  for (int n = 1; n < maxN; n++) {
    c[n][0] = c[n][n] = 1;
    for (int k = 1; k < n; k++)
      c[n][k] = c[n - 1][k - 1] + c[n - 1][k];
  }
  return c;
}
\end{minted}

\needspace{12\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Binomial Coefficient Modulo Large Prime}
\addcontentsline{toc}{subsubsection}{Binomial Coefficient Modulo Large Prime}
\begin{minted}{cpp}
#include "../Number Theory/Modular Multiplicative Inverse.cpp"
#include "Factorials Modulo M.cpp"

typedef long long int li;

// O(lg(p))
li nCk(int n, int k, li p, vector<li> &fact) {
  return fact[n] * modInv(fact[k], p) % p *
         modInv(fact[n - k], p) % p;
}
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Factorials Modulo M}
\addcontentsline{toc}{subsubsection}{Factorials Modulo M}
\begin{minted}{cpp}
typedef long long int li;

vector<li> factorials(int n, li m) {
  vector<li> fact(++n);
  fact[0] = 1;
  for (int i = 1; i < n; i++)
    fact[i] = fact[i - 1] * i % m;
  return fact;
}
\end{minted}

\needspace{15\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Number Theory}
\addcontentsline{toc}{subsection}{Number Theory}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Binary Exponentiation}
\addcontentsline{toc}{subsubsection}{Binary Exponentiation}
\begin{minted}{cpp}
typedef long long int li;

li binPow(li a, li p) {
  li ans = 1LL;
  while (p) {
    if (p & 1LL) ans *= a;
    a *= a, p >>= 1LL;
  }
  return ans;
}
\end{minted}

\needspace{9\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Convert 10-Based Number To Base B}
\addcontentsline{toc}{subsubsection}{Convert 10-Based Number To Base B}
\begin{minted}{cpp}
// O(log(n)) [msb, ..., lsb]
vector<int> toBaseB(int n, int b) {
  vector<int> ans;
  while (n) ans.push_back(n % b), n /= b;
  reverse(ans.begin(), ans.end());
  return ans;
}
\end{minted}

\needspace{9\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Convert B-Based Number To Base 10}
\addcontentsline{toc}{subsubsection}{Convert B-Based Number To Base 10}
\begin{minted}{cpp}
// O(log(n)) [msb, ..., lsb]
int toBase10(vector<int>& n, int b) {
  int ans = 0;
  for (int i = n.size() - 1, p = 1; ~i; i--, p *= b)
    ans += n[i] * p;
  return ans;
}
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Diophantine Equation (Base Solution)}
\addcontentsline{toc}{subsubsection}{Diophantine Equation (Base Solution)}
\begin{minted}{cpp}
#include "Extended Euclidean Algorithm.cpp"
typedef long long int li;
// ax + by = c = gcd(a, b)
pair<li, li> diophantineBase(li a, li b, li c) {
  li d, x, y;
  tie(d, x, y) = extendedGCD(a, b);
  if (c % d) return {0, 0};
  return {c / d * x, c / d * y};
}
\end{minted}

\needspace{13\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Diophantine Equation (Particular Solution)}
\addcontentsline{toc}{subsubsection}{Diophantine Equation (Particular Solution)}
\begin{minted}{cpp}
#include "Extended Euclidean Algorithm.cpp"
typedef long long int li;
// ax + by = c
// returns the i-th solution or {0, 0} if no solutions
pair<li, li> diophantineSol(li a, li b, li c, li i) {
  li d, x, y;
  tie(d, x, y) = extendedGCD(a, b);
  if (c % d) return {0, 0};
  return {c / d * x + i / d * b,
          c / d * y - i / d * a};
}
\end{minted}

\needspace{15\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Divisibility Criterion}
\addcontentsline{toc}{subsubsection}{Divisibility Criterion}
\begin{minted}{py}
def divisorCriteria(n, lim):
    results = []
    tenElevated = 1
    for i in range(lim):
        # remainder = pow(10, i, n)
        remainder = tenElevated % n
        negremainder = remainder - n
        if(remainder <= abs(negremainder)):
            results.append(remainder)
        else:
            results.append(negremainder)
        tenElevated *= 10
    return results


\end{minted}
\vspace{-12pt}
\needspace{14\baselineskip}
\begin{minted}{py}
def testDivisibility(dividend, divisor, divisor_criteria):
    dividend = str(dividend)
    addition = 0
    dividendSize = len(dividend)
    i = dividendSize - 1
    j = 0
    while j < dividendSize:
        addition += int(dividend[i]) * divisor_criteria[j]
        i -= 1
        j += 1
    return addition % divisor == 0


\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{py}
if __name__ == '__main__':
    dividend, divisor = map(int, input().split())
    divisor_criteria = divisorCriteria(divisor, len(str(dividend)))
    print(divisor_criteria)
    print(testDivisibility(dividend, divisor, divisor_criteria))

\end{minted}

\needspace{15\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Divisors}
\addcontentsline{toc}{subsubsection}{Divisors}
\begin{minted}{cpp}
// divs = divisors

typedef long long int li;
typedef vector<li> V;

// O(sqrt(N))
V getDivisors(li n) {
  V divs;
  for (li i = 1; i * i <= n; i++)
    if (!(n % i)) {
      divs.push_back(i);
      if (i * i != n) divs.push_back(n / i);
    }
  return divs;
}
\end{minted}

\needspace{16\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Divisors Pollard Rho}
\addcontentsline{toc}{subsubsection}{Divisors Pollard Rho}
\begin{minted}{cpp}
// pf = primeFactors, divs = divisors

#include "../Primes/Prime Factorization Pollard Rho.cpp"

typedef vector<li> V;

void divisors(Map &pf, V &divs, li ans, li p) {
  auto next = ++pf.find(p);
  int power = pf[p];
  for (li k = 0; k <= power; k++, ans *= p) {
    if (next == pf.end()) divs.push_back(ans);
    else divisors(pf, divs, ans, next->first);
  }
}
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
// O(number of pf)
V getDivisors(li n) {
  Map pf = getPrimeFactors(n);
  V divs;
  divisors(pf, divs, 1, pf.begin()->first);
  return divs;
}
\end{minted}

\needspace{13\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Euler's Phi}
\addcontentsline{toc}{subsubsection}{Euler's Phi}
\begin{minted}{cpp}
#include "../Primes/Prime Factorization Pollard Rho.cpp"
// #include "../Primes/Prime Factorization.cpp"

// counts the number of integers (Xi) between 1 and n
// which are coprime (gcd(Xi, n) = 1) to n
li phi(li n) {
  Map pf = getPrimeFactors(n);
  if (pf.count(n)) return n - 1;  // if n is prime
  for (auto &p : pf) n -= n / p.first;
  return n;
}
\end{minted}

\needspace{13\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Extended Euclidean Algorithm}
\addcontentsline{toc}{subsubsection}{Extended Euclidean Algorithm}
\begin{minted}{cpp}
#include "../../Util/Modulo with negative numbers.cpp"
#include "../../Util/Floor Of Division Between Integers.cpp"
typedef long long int li;

// gcd(a, b) = ax + by
tuple<li, li, li> extendedGCD(li a, li b) {
  if (!a) return {b, 0, 1};
  li d, x, y;
  tie(d, x, y) = extendedGCD(mod(b, a), a);
  return {d, y - floor(b, a) * x, x};
}  // {gcd(a, b), x, y}
\end{minted}

\needspace{7\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{GCD}
\addcontentsline{toc}{subsubsection}{GCD}
\begin{minted}{cpp}
typedef long long int li;

li gcd(li a, li b) {
  return !b ? a : gcd(b, a % b);
}
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
// Iterative version
li gcdI(li a, li b) {
  while (b) a %= b, swap(a, b);
  return a;
}
\end{minted}

\needspace{8\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{LCM}
\addcontentsline{toc}{subsubsection}{LCM}
\begin{minted}{cpp}
#include "GCD.cpp"

int lcm(li a, li b) {
  int d = gcd(a, b);
  return d ? a / d * b : 0;
}
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Modular Exponentiation}
\addcontentsline{toc}{subsubsection}{Modular Exponentiation}
\begin{minted}{cpp}
#include "./Modular Multiplication.cpp"

// O(lg(p))
li pow(li a, li p, li m) {
  li ans = 1;
  for (a %= m; p; a = multiply(a, a, m), p >>= 1)
    if (p & 1LL) ans = multiply(ans, a, m);
  return ans;
}
\end{minted}

\needspace{13\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Modular Multiplication}
\addcontentsline{toc}{subsubsection}{Modular Multiplication}
\begin{minted}{cpp}
typedef long long int li;

// O(lg(b))
li multiply(li a, li b, li m) {
  li ans = 0;
  for (a %= m; b;
       b >>= 1, a <<= 1, a = (a < m ? a : a - m))
    if (b & 1)
      ans += a, ans = (ans < m ? ans : ans - m);
  return ans;
}
\end{minted}

\needspace{12\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Modular Multiplicative Inverse}
\addcontentsline{toc}{subsubsection}{Modular Multiplicative Inverse}
\begin{minted}{cpp}
// n = number, m = modulo
#include "Extended Euclidean Algorithm.cpp"

// O(lg(N))
li modInv(li n, li m) {
  li g, x, y;
  tie(g, x, y) = extendedGCD(n, m);
  if (g != 1) throw "No solution";
  return (x % m + m) % m;
}
\end{minted}

\needspace{10\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Modular Multiplicative Inverses Modulo M [1, M)}
\addcontentsline{toc}{subsubsection}{Modular Multiplicative Inverses Modulo M [1, M)}
\begin{minted}{cpp}
// O(m)
vector<int> modinvs(int m) {
  vector<int> inv(m);
  inv[1] = 1;
  for (int i = 2; i < m; i++)
    inv[i] = (m - (m / i) * inv[m % i] % m) % m;
  return inv;
}
\end{minted}

\needspace{30\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Primes}
\addcontentsline{toc}{subsection}{Primes}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Is Prime Miller Rabin}
\addcontentsline{toc}{subsubsection}{Is Prime Miller Rabin}
\begin{minted}{cpp}
#include "../Number Theory/Modular Exponentiation.cpp"

bool isPrime(li p, int k = 20) {
  if (p == 2 || p == 3) return 1;
  if ((~p & 1) || p == 1) return 0;
  li d = p - 1, phi = d, r = 0;
  while (~d & 1) d >>= 1, r++;
  while (k--) {
    // set seed with: int main() { srand(time(0)); }
    li a = 2 + rand() % (p - 3);  // [2, p - 2]
    li e = pow(a, d, p), r2 = r;
    if (e == 1 || e == phi) continue;
    bool flag = 1;
    while (--r2) {
      e = multiply(e, e, p);
      if (e == 1) return 0;
      if (e == phi) {
        flag = 0;
        break;
      }
    }
    if (flag) return 0;
  }
  return 1;
}
\end{minted}

\needspace{19\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Prime Factorization Up To 1e12}
\addcontentsline{toc}{subsubsection}{Prime Factorization Up To 1e12}
\begin{minted}{cpp}
#include "Primes Sieve.cpp"

typedef long long int li;
typedef map<li, int> Map;

// O(#Primes * lg(N)), n <= sieve.size() ^ 2
Map getPrimeFactors(li n) {
  Map pf;
  for (int& p : primes) {
    if (p * p > n) break;
    int c = 0;
    while (n % p == 0) n /= p, c++;
    if (c) pf[p] = c;
  }
  if (n > 1) pf[n] = 1;
  return pf;
}
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Prime Factorization Up To 1e18}
\addcontentsline{toc}{subsubsection}{Prime Factorization Up To 1e18}
\begin{minted}{cpp}
// pf = prime factors

#include "../Number Theory/GCD.cpp"
#include "./Is Prime Miller Rabin.cpp"

typedef long long int li;
typedef map<li, int> Map;

li _abs(li a) { return a < 0 ? -a : a; }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
li getRandomDivisor(li n) {
  if (~n & 1) return 2;
  li c = 1 + rand() % (n - 1), a = 2, b = 2, d = 1;
  auto f = [&](li x) {
    return (multiply(x, x, n) + c) % n;
  };
  while (d == 1)
    a = f(a), b = f(f(b)), d = gcd(_abs(a - b), n);
  return d;
}
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
void getpf(li n, Map &pf) {
  if (n == 1LL) return;
  if (isPrime(n)) {
    pf[n]++;
    return;
  }
  li divisor = getRandomDivisor(n);
  getpf(divisor, pf), getpf(n / divisor, pf);
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
// ~O(N^(1/4))
Map getPrimeFactors(li n) {
  Map pf;
  getpf(n, pf);
  return pf;
}
\end{minted}

\needspace{17\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Prime Factorization Up To 1e6}
\addcontentsline{toc}{subsubsection}{Prime Factorization Up To 1e6}
\begin{minted}{cpp}
#include "Primes Sieve.cpp"

typedef map<int, int> Map;

// O(lg(N)) n <= sieve.size()
Map getPrimeFactors(int n) {
  Map pf;
  while (n > 1) {
    int p = n & 1 ? sieve[n] : 2, c = 0;
    if (!p) p = n;
    while (n % p == 0) n /= p, c++;
    pf[p] = c;
  }
  return pf;
}
\end{minted}

\needspace{14\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Prime Factorization Up To 1e9}
\addcontentsline{toc}{subsubsection}{Prime Factorization Up To 1e9}
\begin{minted}{cpp}
typedef long long int li;
typedef map<li, int> Map;

// ~O(sqrt(N) * lg(N))
Map getPrimeFactors(li n) {
  Map pf;
  while (~n & 1) pf[2]++, n >>= 1;
  for (li i = 3; i * i <= n; i += 2)
    while (!(n % i)) pf[i]++, n /= i;
  if (n > 1) pf[n]++;
  return pf;
}
\end{minted}

\needspace{20\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Primes Sieve}
\addcontentsline{toc}{subsubsection}{Primes Sieve}
\begin{minted}{cpp}
// sieve[i] = lowest prime factor of i
// sieve[even number] = 0
// sieve[prime] = 0

vector<int> sieve, primes;

// ~O(N * lg(lg(N)))
void primeSieve(int n) {
  sieve.assign(n + 1, 0);
  primes = {};
  for (int i = 3; i * i <= n; i += 2)
    if (!sieve[i])
      for (int j = i * i; j <= n; j += 2 * i)
        if (!sieve[j]) sieve[j] = i;
  primes.push_back(2);
  for (int i = 3; i <= n; i++)
    if (!sieve[i] && (i & 1)) primes.push_back(i);
}
\end{minted}

\needspace{16\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Ranges}
\markboth{RANGES}{}
\addcontentsline{toc}{section}{Ranges}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Data Structures}
\addcontentsline{toc}{subsection}{Data Structures}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{BIT}
\addcontentsline{toc}{subsubsection}{BIT}
\begin{minted}{cpp}
// 0-indexed
#include "../../BITs Manipulation/Most Significant Set Bit.cpp";

template <class T>
struct BIT {
  T neutro = 0;
  vector<T> bit;
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
  BIT(int n) { bit.assign(++n, neutro); }

  inline T F(T a, T b) {
    return a + b;
    // return a * b;
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // Inverse of F
  inline T I(T a, T b) {
    return a - b;
    // return a / b;
  }
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
  // O(N)
  void build() {
    for (int i = 1; i < bit.size(); i++) {
      int j = i + (i & -i);
      if (j < bit.size()) bit[j] = F(bit[j], bit[i]);
    }
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void update(int i, T val) {
    for (i++; i < bit.size(); i += i & -i)
      bit[i] = F(bit[i], val);
  }
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  T query(int i) {
    T ans = neutro;
    for (i++; i; i -= i & -i) ans = F(ans, bit[i]);
    return ans;
  }
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), [l, r]
  T query(int l, int r) {
    return I(query(r), query(--l));
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)) binary search in prefix sum array
  T lowerBound(T x) {
    T acum = neutro;
    int pos = 0;
    for (int i = msb(bit.size() - 1); i; i >>= 1)
      if ((pos | i) < bit.size() &&
          F(acum, bit[pos | i]) < x)
        acum = F(acum, bit[pos |= i]);
    return pos;
  }

  T& operator[](int i) { return bit[++i]; }
};
\end{minted}

\needspace{5\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{BIT Range Update}
\addcontentsline{toc}{subsubsection}{BIT Range Update}
\begin{minted}{cpp}
typedef long long int T;
T neutro = 0;
vector<T> bit1, bit2;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void initVars(int n) {
  bit1.assign(++n, neutro);
  bit2 = bit1;
}
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
// O(lg(N))
void update(vector<T> &bit, int i, T val) {
  for (i++; i < bit.size(); i += i & -i)
    bit[i] += val;
}
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
// O(lg(N)), [l, r]
void update(int l, int r, T val) {
  update(bit1, l, val);
  update(bit1, r + 1, -val);
  update(bit2, r + 1, val * r);
  update(bit2, l, -val * (l - 1));
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
// O(lg(N))
T query(vector<T> &bit, int i) {
  T ans = neutro;
  for (i++; i; i -= i & -i) ans += bit[i];
  return ans;
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
// O(lg(N))
T query(int i) {
  return query(bit1, i) * i + query(bit2, i);
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
// O(lg(N)), [l, r]
T query(int l, int r) {
  return query(r) - query(l - 1);
}
\end{minted}

\needspace{6\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Segment Tree}
\addcontentsline{toc}{subsubsection}{Segment Tree}
\begin{minted}{cpp}
// st = segment tree. st[1] = root;
// neutro = operation neutral value
// e.g. for sum is 0, for multiplication
// is 1, for gcd is 0, for min is INF, etc.
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
template <class T>
struct SegmentTree {
  T neutro = 0;
  int N;
  vector<T> st;
  function<T(T, T)> F;
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  SegmentTree(int n, int neut,
      T f(T, T) = [](T a, T b) { return a + b; })
      : neutro(neut), st(2 * n, neutro), N(n), F(f) {}
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(2N)
  void build() {
    for (int i = N - 1; i; i--)
      st[i] = F(st[i << 1], st[i << 1 | 1]);
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(lg(2N)), works like replacing arr[i] with val
  void update(int i, T val) {
    for (st[i += N] = val; i > 1; i >>= 1)
      st[i >> 1] = F(st[i], st[i ^ 1]);
  }
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
  // O(lg(2N)), [l, r]
  T query(int l, int r) {
    T ans = neutro;
    for (l += N, r += N; l <= r; l >>= 1, r >>= 1) {
      if (l & 1) ans = F(ans, st[l++]);
      if (~r & 1) ans = F(ans, st[r--]);
    }
    return ans;
  }
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
  T& operator[](int i) { return st[i + N]; }
};
\end{minted}

\needspace{7\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Segment Tree Lazy Propagation}
\addcontentsline{toc}{subsubsection}{Segment Tree Lazy Propagation}
\begin{minted}{cpp}
// st = segment tree, st[1] = root, H = height of d
// u = updates, d = delayed updates
// neutro = operation neutral val
// e.g. for sum is 0, for multiplication
// is 1, for gcd is 0, for min is INF, etc.
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
template <class T>
struct SegmentTree {
  T neutro = 0;
  int N, H;
  vector<T> st, d;
  vector<bool> u;
  function<T(T, T)> F;
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  SegmentTree(int n, T val,
      T f(T, T) = [](T a, T b) { return a + b; })
      : st(2 * n, val), d(n), u(n), F(f) {
    H = sizeof(int) * 8 - __builtin_clz(N = n);
  }
  \end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
  void apply(int i, T val, int k) {
    // operation to update st[i] in O(1) time
    st[i] += val * k;  // updates the tree
    // operation to update d[i] in O(1) time
    // which updates values for future updates
    if (i < N) d[i] += val, u[i] = 1;
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  void calc(int i) {
    if (!u[i]) st[i] = F(st[i << 1], st[i << 1 | 1]);
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(2N)
  void build() {
    for (int i = N - 1; i; i--) calc(i);
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void build(int p) {
    while (p > 1) p >>= 1, calc(p);
  }
\end{minted}
\vspace{-12pt}
\needspace{12\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void push(int p) {
    for (int s = H, k = 1 << (H - 1); s;
         s--, k >>= 1) {
      int i = p >> s;
      if (u[i]) {
        apply(i << 1, d[i], k);
        apply(i << 1 | 1, d[i], k);
        u[i] = 0, d[i] = 0;
      }
    }
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), [l, r]
  void update(int l, int r, T val) {
    push(l += N), push(r += N);
    int ll = l, rr = r, k = 1;
    for (; l <= r; l >>= 1, r >>= 1, k <<= 1) {
      if (l & 1) apply(l++, val, k);
      if (~r & 1) apply(r--, val, k);
    }
    build(ll), build(rr);
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(lg(2N)), [l, r]
  T query(int l, int r) {
    push(l += N), push(r += N);
    T ans = neutro;
    for (; l <= r; l >>= 1, r >>= 1) {
      if (l & 1) ans = F(ans, st[l++]);
      if (~r & 1) ans = F(ans, st[r--]);
    }
    return ans;
  }
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
  T& operator[](int i) { return st[i + N]; }
};
\end{minted}

\needspace{8\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Sparse Table}
\addcontentsline{toc}{subsubsection}{Sparse Table}
\begin{minted}{cpp}
// st = sparse table, Arith = Arithmetic
template <class T>
struct SparseTable {
  vector<vector<T>> st;
  function<T(T, T)> F;
  SparseTable() {}
\end{minted}
\vspace{-12pt}
\needspace{12\baselineskip}
\begin{minted}{cpp}
  // O(N * lg(N))
  SparseTable(vector<T> &v,
      T f(T, T) = [](T a, T b) { return a + b; })
      : F(f) {
    st.assign(1 + log2(v.size()),
              vector<T>(v.size()));
    st[0] = v;
    for (int i = 1; (1 << i) <= v.size(); i++)
      for (int j = 0; j + (1 << i) <= v.size(); j++)
        st[i][j] = F(st[i - 1][j],
                     st[i - 1][j + (1 << (i - 1))]);
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(1), [l, r]
  T query(int l, int r) {
    int i = log2(r - l + 1);
    return F(st[i][l], st[i][r + 1 - (1 << i)]);
  }
\end{minted}
\vspace{-12pt}
\needspace{12\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), [l, r]
  T queryArith(int l, int r) {
    T ans = 0; // neutral value
    while (true) {
      int k = log2(r - l + 1);
      ans = F(ans, st[k][l]);
      l += 1 << k;
      if (l > r) break;
    }
    return ans;
  }
};
\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Wavelet Tree}
\addcontentsline{toc}{subsubsection}{Wavelet Tree}
\begin{minted}{cpp}
// pref = prefix sum
// lte = less than or equal, 1-indexed
// A = hi = max_element(from, to)
// lcount = left children count
// lo = min_element(from, to)
struct WaveletTree {
  WaveletTree *l, *r;
  int lo, hi;
  vector<int> lcount, pref;
\end{minted}
\vspace{-12pt}
\needspace{17\baselineskip}
\begin{minted}{cpp}
  // O(N*lg(A))
  WaveletTree(vector<int>::iterator from,
              vector<int>::iterator to, int lo,
              int hi) {
    this->lo = lo, this->hi = hi;
    if (lo == hi or from >= to) return;
    int mid = (lo + hi) >> 1;
    auto f = [mid](int x) { return x <= mid; };
    lcount.reserve(to - from + 1);
    pref.reserve(to - from + 1);
    lcount.push_back(0);
    pref.push_back(0);
    for (auto it = from; it != to; it++)
      lcount.push_back(lcount.back() + f(*it)),
          pref.push_back(pref.back() + *it);
    auto pivot = stable_partition(from, to, f);
    l = new WaveletTree(from, pivot, lo, mid);
    r = new WaveletTree(pivot, to, mid + 1, hi);
  }
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
  // O(lg(A)) frequency of k in [a, b]
  int freq(int a, int b, int k) {
    if (a > b or k < lo or k > hi) return 0;
    if (lo == hi) return b - a + 1;
    int lc = lcount[a - 1], rc = lcount[b];
    if (k > ((lo + hi) >> 1))
      return r->freq(a - lc, b - rc, k);
    return l->freq(lc + 1, rc, k);
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(lg(A)) kth-Smallest element in [a, b]
  int kth(int a, int b, int k) {
    if (a > b) return 0;
    if (lo == hi) return lo;
    int lc = lcount[a - 1], rc = lcount[b],
        inleft = rc - lc;
    if (k > inleft)
      return r->kth(a - lc, b - rc, k - inleft);
    return l->kth(lc + 1, rc, k);
  }
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  // O(lg(A)) count of elements <= to k in [a, b]
  int lte(int a, int b, int k) {
    if (a > b or k < lo) return 0;
    if (hi <= k) return b - a + 1;
    int lc = lcount[a - 1], rc = lcount[b];
    return l->lte(lc + 1, rc, k) +
           r->lte(a - lc, b - rc, k);
  }
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  // O(lg(A)) sum of numbers <= to k in [a, b]
  int sumlte(int a, int b, int k) {
    if (a > b or k < lo) return 0;
    if (hi <= k) return pref[b] - pref[a - 1];
    int lc = lcount[a - 1], rc = lcount[b];
    return l->sumlte(lc + 1, rc, k) +
           r->sumlte(a - lc, b - rc, k);
  }
};
\end{minted}

\needspace{14\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Strings}
\markboth{STRINGS}{}
\addcontentsline{toc}{section}{Strings}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Data Structures}
\addcontentsline{toc}{subsection}{Data Structures}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Suffix Automaton}
\addcontentsline{toc}{subsubsection}{Suffix Automaton}
\begin{minted}{cpp}
// link[u]: links to the longest suffix which is
//          not in the same endpos-equivalence class
// len[u]: length of the longest suffix that
//         corresponds to u's endpos-equivalence class
// next[0]: root of suffix automaton
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
struct SuffixAutomaton {
  vector<int> len, link, isClone, first;
  vector<map<char, int>> next;
  int size, last;
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  void init(int n) {
    first = isClone = len = link = vector<int>(2 * n);
    next.resize(2 * n);
    len[0] = 0, link[0] = -1, size = 1, last = 0;
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(N)
  SuffixAutomaton(const string& s) {
    init(s.size());
    for (const auto& c : s) add(c);
  }
\end{minted}
\vspace{-12pt}
\needspace{22\baselineskip}
\begin{minted}{cpp}
  // O(1)
  void add(const char& c) {
    int p = last, u = size++;
    len[u] = len[p] + 1, first[u] = len[p];
    while (p != -1 && !next[p].count(c))
      next[p][c] = u, p = link[p];
    if (p == -1) link[u] = 0;
    else {
      int q = next[p][c];
      if (len[p] + 1 == len[q]) link[u] = q;
      else {
        int clone = size++;
        first[clone] = first[q];
        len[clone] = len[p] + 1, isClone[clone] = 1;
        link[clone] = link[q], next[clone] = next[q];
        while (p != -1 && next[p][c] == q)
          next[p][c] = clone, p = link[p];
        link[q] = link[u] = clone;
      }
    }
    last = u;
  }
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
  // O(N)
  unordered_set<int> getTerminals() {
    unordered_set<int> terminals;
    for (int p = last; p; p = link[p])
      terminals.insert(p);
    return terminals;
  }
};
\end{minted}

\needspace{5\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Trie}
\addcontentsline{toc}{subsubsection}{Trie}
\begin{minted}{cpp}
// wpt = number of words passing through
// w = number of words ending in the node
// c = character
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
struct Trie {

  struct Node {
    // for lexicographical order use 'map'
    // map<char, Node *> ch;
    unordered_map<char, Node *> ch;
    int w = 0, wpt = 0;
  };
\end{minted}
\vspace{-12pt}
\needspace{12\baselineskip}
\begin{minted}{cpp}
  Node *root = new Node();

  // O(STR.SIZE)
  void insert(string str) {
    Node *curr = root;
    for (auto &c : str) {
      if (!curr->ch.count(c))
        curr->ch[c] = new Node();
      curr->wpt++, curr = curr->ch[c];
    }
    curr->wpt++, curr->w++;
  }
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
  // O(STR.SIZE)
  Node *find(string &str) {
    Node *curr = root;
    for (auto &c : str) {
      if (!curr->ch.count(c)) return nullptr;
      curr = curr->ch[c];
    }
    return curr;
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(STR.SIZE) number of words with given prefix
  int prefixCount(string prefix) {
    Node *node = find(prefix);
    return node ? node->wpt : 0;
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(STR.SIZE) number of words matching str
  int strCount(string str) {
    Node *node = find(str);
    return node ? node->w : 0;
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(N)
  void getWords(Node *curr, vector<string> &words,
                string &word) {
    if (!curr) return;
    if (curr->w) words.push_back(word);
    for (auto &c : curr->ch) {
      getWords(c.second, words, word += c.first);
      word.pop_back();
    }
  }
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
  // O(N)
  vector<string> getWords() {
    vector<string> words;
    string word = "";
    getWords(root, words, word);
    return words;
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(N)
  vector<string> getWordsByPrefix(string prefix) {
    vector<string> words;
    getWords(find(prefix), words, prefix);
  }
\end{minted}
\vspace{-12pt}
\needspace{15\baselineskip}
\begin{minted}{cpp}
  // O(STR.SIZE)
  bool remove(Node *curr, string &str, int &i) {
    if (i == str.size()) {
      curr->wpt--;
      return curr->w ? !(curr->w = 0) : 0;
    }
    int c = str[i];
    if (!curr->ch.count(c)) return false;
    if (remove(curr->ch[c], str, ++i)) {
      if (!curr->ch[c]->wpt)
        curr->wpt--, curr->ch.erase(c);
      return true;
    }
    return false;
  }
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
  // O(STR.SIZE)
  int remove(string str) {
    int i = 0;
    return remove(root, str, i);
  }
};
\end{minted}

\needspace{16\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Distinct Substring Count}
\addcontentsline{toc}{subsection}{Distinct Substring Count}
\begin{minted}{cpp}
#include "Data Structures/Suffix Automaton.cpp"

// O(N)
int distinctSubstrCount(const string& s) {
  SuffixAutomaton sa(s);
  vector<int> dp(sa.size);
  function<int(int)> dfs = [&](int u) {
    if (dp[u]) return dp[u];
    for (auto& v : sa.next[u]) dp[u] += dfs(v.second);
    return ++dp[u];
  };
  return dfs(0) - 1;
}
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{KMP}
\addcontentsline{toc}{subsection}{KMP}
\begin{minted}{cpp}
// p = pattern, t = text
// f = error function, cf = create error function
// pos = positions where pattern is found in text
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
int MAXN = 1000000;
vector<int> f(MAXN + 1);
\end{minted}
\vspace{-12pt}
\needspace{12\baselineskip}
\begin{minted}{cpp}
vector<int> kmp(string &p, string &t, int cf) {
  vector<int> pos;
  if (cf) f[0] = -1;
  for (int i = cf, j = 0; j < t.size();) {
    while (i > -1 && p[i] != t[j]) i = f[i];
    i++, j++;
    if (cf) f[j] = i;
    if (!cf && i == p.size())
      pos.push_back(j - i), i = f[i];
  }
  return pos;
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
vector<int> search(string &p, string &t) {
  kmp(p, p, -1);        // create error function
  return kmp(p, t, 0);  // search in text
}
\end{minted}

\needspace{15\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Levenshtein Distance (Bottom-Up)}
\addcontentsline{toc}{subsection}{Levenshtein Distance (Bottom-Up)}
\begin{minted}{cpp}
int editDistance(string& s, string& t) {
  vector<vector<int>> dp(t.size() + 1,
                         vector<int>(s.size() + 1));
  for (int i = 1; i <= s.size(); i++) dp[0][i] = i;
  for (int i = 1; i <= t.size(); i++) dp[i][0] = i;
  for (int i = 0; i < t.size(); i++)
    for (int j = 0; j < s.size(); j++)
      dp[i + 1][j + 1] =
          min(dp[i][j] + (t[i] != s[j]),
              min(dp[i][j + 1], dp[i + 1][j]) + 1);
  return dp[t.size()][s.size()];
}
\end{minted}

\needspace{15\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Levenshtein Distance (Top-Down)}
\addcontentsline{toc}{subsection}{Levenshtein Distance (Top-Down)}
\begin{minted}{cpp}
// i and j are last indexes of s and t respectively
int editDistance(string& s, string& t, int i, int j,
                 vector<vector<int>>& dp) {
  if (i < 0) return j + 1;
  if (j < 0) return i + 1;
  if (dp[i][j] != -1) return dp[i][j];
  int replace = editDistance(s, t, i - 1, j - 1, dp);
  int insert = editDistance(s, t, i, j - 1, dp);
  int remove = editDistance(s, t, i - 1, j, dp);
  return dp[i][j] = min(replace + (s[i] != t[j]),
                        min(insert, remove) + 1);
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Levenshtein-Damerau Distance}
\addcontentsline{toc}{subsection}{Levenshtein-Damerau Distance}
\begin{minted}{cpp}

\end{minted}

\needspace{16\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Lexicographically K-th Substring}
\addcontentsline{toc}{subsection}{Lexicographically K-th Substring}
\begin{minted}{cpp}
#include "Data Structures/Suffix Automaton.cpp"
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
// O(N * ks.size)
vector<string> kthSubstr(string& s, vector<int>& ks) {
  SuffixAutomaton sa(s);
  vector<int> dp(sa.size);
  function<int(int)> dfs = [&](int u) {
    if (dp[u]) return dp[u];
    for (auto& v : sa.next[u]) dp[u] += dfs(v.second);
    return ++dp[u];
  };
\end{minted}
\vspace{-12pt}
\needspace{16\baselineskip}
\begin{minted}{cpp}
  dfs(0);
  vector<string> ans;
  for (auto k : ks) {
    int u = 0;
    string ss;
    while (k)
      for (auto& v : sa.next[u])
        if (k <= dp[v.second]) {
          ss += v.first, u = v.second, k--;
          break;
        } else
          k -= dp[v.second];
    ans.push_back(ss);
  }
  return ans;
}
\end{minted}

\needspace{16\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Lexicographically Smallest Cyclic Shift}
\addcontentsline{toc}{subsection}{Lexicographically Smallest Cyclic Shift}
\begin{minted}{cpp}
#include "Data Structures/Suffix Automaton.cpp"

// O(N)
string smallestCyclicShift(const string& s) {
  SuffixAutomaton sa(s + s);
  int k = s.size(), u = 0;
  string ans;
  while(k) {
    auto &v = *sa.next[u].begin();
    ans += v.first, u = v.second, k--;
  }
  return ans;
}
\end{minted}

\needspace{17\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Longest Common Substring of 2 Strings}
\addcontentsline{toc}{subsection}{Longest Common Substring of 2 Strings}
\begin{minted}{cpp}
#include "Data Structures/Suffix Automaton.cpp"

string lcs(string& a, string& b) {
  SuffixAutomaton sa(a);
  int bestLen = 0, bestPos = -1;
  for (int i = 0, u = 0, l = 0; i < b.size(); i++) {
    while (u && !sa.next[u].count(b[i]))
      u = sa.link[u], l = sa.len[u];
    if (sa.next[u].count(b[i]))
      u = sa.next[u][b[i]], l++;
    if (l > bestLen) bestLen = l, bestPos = i;
  }
  return b.substr(bestPos - bestLen + 1, bestLen);
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Longest Common Substring of Several Strings}
\addcontentsline{toc}{subsection}{Longest Common Substring of Several Strings}
\begin{minted}{cpp}
#include <bits/stdc++.h>
using namespace std;

#include "Data Structures/Suffix Automaton.cpp"

string lcs(vector<string>& ss) {
  
}

int main() {

}
\end{minted}

\needspace{7\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Number of Ocurrences Of Several Words}
\addcontentsline{toc}{subsection}{Number of Ocurrences Of Several Words}
\begin{minted}{cpp}
// t: text, ps: patterns
// cnt[u]: size of u's endpos set

#include "Data Structures/Suffix Automaton.cpp"
\end{minted}
\vspace{-12pt}
\needspace{23\baselineskip}
\begin{minted}{cpp}
// O(T * Lg(T) + p.size() * ps.size())
vector<int> nOcurrences(string& t,
                        vector<string>& ps) {
  SuffixAutomaton sa(t);
  vector<int> cnt(sa.size), aux(sa.size), ans;
  for (int u = 0; u < sa.size; aux[u] = u, u++)
    if (!sa.isClone[u]) cnt[u] = 1;
  sort(aux.begin(), aux.end(), [&](int& a, int& b) {
    return sa.len[b] < sa.len[a];
  });
  for (auto& u : aux)
    if (u) cnt[sa.link[u]] += cnt[u];
  for (auto& p : ps)
    for (int u = 0, i = 0; i < p.size(); i++) {
      if (!sa.next[u].count(p[i])) {
        ans.push_back(0);
        break;
      }
      u = sa.next[u][p[i]];
      if (i + 1 == p.size()) ans.push_back(cnt[u]);
    }
  return ans;
}
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Ocurrences Positions Of Several Words}
\addcontentsline{toc}{subsection}{Ocurrences Positions Of Several Words}
\begin{minted}{cpp}
// invLink = inverse suffix-link

#include "Data Structures/Suffix Automaton.cpp"
\end{minted}
\vspace{-12pt}
\needspace{28\baselineskip}
\begin{minted}{cpp}
// O(T + OCURRENCES(ps[i]) * ps.size())
vector<vector<int>> ocurrencesPos(
    string& t, vector<string>& ps) {
  SuffixAutomaton sa(t);
  vector<vector<int>> ans, invLink(sa.size);
  for (int u = 1; u < sa.size; u++)
    invLink[sa.link[u]].push_back(u);
  function<void(int, int, vector<int>&)> dfs =
      [&](int u, int pLen, vector<int>& oc) {
        if (!sa.isClone[u])
          oc.push_back(sa.first[u] - pLen + 1);
        for (auto& v : invLink[u]) dfs(v, pLen, oc);
      };

  for (auto& p : ps)
    for (int u = 0, i = 0; i < p.size(); i++) {
      if (!sa.next[u].count(p[i])) {
        ans.push_back({});
        break;
      }
      u = sa.next[u][p[i]];
      if (i + 1 == p.size()) {
        vector<int> oc;
        dfs(u, p.size(), oc), ans.push_back(oc);
      }
    }
  return ans;
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Rabin Karp}
\addcontentsline{toc}{subsection}{Rabin Karp}
\begin{minted}{cpp}
class RollingHash {
 public:
  vector<unsigned long long int> pow;
  vector<unsigned long long int> hash;
  unsigned long long int B;
\end{minted}
\vspace{-12pt}
\needspace{13\baselineskip}
\begin{minted}{cpp}
  RollingHash(const string &text) : B(257) {
    int N = text.size();
    pow.resize(N + 1);
    hash.resize(N + 1);
    pow[0] = 1;
    hash[0] = 0;
    for (int i = 1; i <= N; ++i) {
      // in c++ an unsigned long long int is
      // automatically modulated by 2^64
      pow[i] = pow[i - 1] * B;
      hash[i] = hash[i - 1] * B + text[i - 1];
    }
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  unsigned long long int getWordHash() {
    return hash[hash.size() - 1];
  }
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  unsigned long long int getSubstrHash(int begin,
                                       int end) {
    return hash[end] -
           hash[begin - 1] * pow[end - begin + 1];
  }

  int size() { return hash.size(); }
};
\end{minted}
\vspace{-12pt}
\needspace{14\baselineskip}
\begin{minted}{cpp}
vector<int> rabinKarp(RollingHash &rhStr,
                      string &pattern) {
  vector<int> positions;
  RollingHash rhPattern(pattern);
  unsigned long long int patternHash =
      rhPattern.getWordHash();
  int windowSize = pattern.size(), end = windowSize;
  for (int i = 1; end < rhStr.size(); i++) {
    if (patternHash == rhStr.getSubstrHash(i, end))
      positions.push_back(i);
    end = i + windowSize;
  }
  return positions;
}
\end{minted}

\needspace{21\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Techniques}
\markboth{TECHNIQUES}{}
\addcontentsline{toc}{section}{Techniques}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Array Compression (Coordinate Compression)}
\addcontentsline{toc}{subsection}{Array Compression (Coordinate Compression)}
\begin{minted}{cpp}
// c = compressed
typedef int T;
map<T, int> Map;
map<int, T> imap;

template <class T> // don't pass n as param
vector<int> compress(vector<T>& v, int n = 0) {
  set<T> s(v.begin(), v.end());
  vector<int> c(v.size());
  for (auto& e : s) Map[e] = n++;
  for (int i = 0; i < v.size(); i++)
    c[i] = Map[v[i]], imap[c[i]] = v[i];
  return c;
}
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Map Value To Int}
\addcontentsline{toc}{subsection}{Map Value To Int}
\begin{minted}{cpp}
// val = value
typedef string Val;
map<Val, int> intForVal;
map<int, Val> valForInt;
int mapId = 0;
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
int Map(Val val) {
  if (intForVal.count(val)) return intForVal[val];
  valForInt[mapId] = val;
  return intForVal[val] = mapId++;
}

Val IMap(int n) { return valForInt[n]; }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
void initMapping() {
  mapId = 0;
  intForVal.clear();
  valForInt.clear();
}
\end{minted}

\needspace{15\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Binary Search}
\addcontentsline{toc}{subsection}{Binary Search}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Binary Search}
\addcontentsline{toc}{subsubsection}{Binary Search}
\begin{minted}{cpp}
/* if e in v and lower = false (upper_bound):
  r = position of e in v
  l = r + 1
if e in v and lower = true (lower_bound):
  l = position of e in v
  r = l - 1
if e not in v and inv = false it means that:
  v[r] < e < v[l]
if e not in v and inv = true it means that:
  v[r] > e > v[l] */
\end{minted}
\vspace{-12pt}
\needspace{16\baselineskip}
\begin{minted}{cpp}
// O(lg(r - l)) [l, r]
template <class T>
vector<T> bSearch(vector<T> &v, int l, int r, T e,
                  bool lower = 0, bool inv = 0) {
  int ll = l, rr = r;
  while (l <= r) {
    int mid = l + (r - l) >> 1;
    if (e < v[mid]) inv ? l = mid + 1 : r = mid - 1;
    else if (e > v[mid])
      inv ? r = mid - 1 : l = mid + 1;
    else
      lower ? r = mid - 1 : l = mid + 1;
  }  // bSearch[0] tells if the element was found
  return {lower ?
    v[min(rr, l)] == e : v[max(ll, r)] == e, r, l};
}
\end{minted}

\needspace{4\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Bitonic Search}
\addcontentsline{toc}{subsubsection}{Bitonic Search}
\begin{minted}{cpp}
/* assumes that the bitonic point is the greastest
 * value in v*/

\end{minted}
\vspace{-12pt}
\needspace{19\baselineskip}
\begin{minted}{cpp}
#include "Binary Search.cpp"

template <class T>
vector<vector<int>> bitonicSearch(vector<T> &v, T e) {
  int l = 0, r = v.size() - 1, mid;
  while (l <= r) {
    mid = l + (r - l) / 2;
    if (!mid || (mid >= v.size() - 1)) break;
    if (v[mid - 1] <= v[mid] && v[mid] > v[mid + 1])
      break;
    if (v[mid - 1] <= v[mid] && v[mid] <= v[mid + 1])
      l = mid + 1;
    if (v[mid - 1] > v[mid] && v[mid] > v[mid + 1])
      r = mid - 1;
  }  // at the end of the loop mid = bitonic point
  return {
      bSearch<T>(v, e, 0, mid),
      bSearch<T>(v, e, mid, v.size() - 1, false, true)};
}
\end{minted}

\needspace{12\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{C++ lower bound}
\addcontentsline{toc}{subsubsection}{C++ lower bound}
\begin{minted}{cpp}
// ans[0] = true if e is in v else false
// ans[1] = index pointing to the first element in
// the range [l, r) which compares >= to e.
template <class T>
vector<int> lowerBound(vector<T>& v, int l, int r,
                       T e) {
  auto it = v.begin();
  int i = lower_bound(it + l, it + r, e) - it;
  return {v[i] == e, i};
}
\end{minted}

\needspace{12\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{C++ upper bound}
\addcontentsline{toc}{subsubsection}{C++ upper bound}
\begin{minted}{cpp}
// ans[0] = true if e is in v else false
// ans[1] = index pointing to the first element in
// the range [l, r) which compares > to e.
template <class T>
vector<int> upperBound(vector<T>& v, int l, int r,
                       T e) {
  auto it = v.begin();
  int i = upper_bound(it + l, it + r, e) - it;
  return {v[i - 1] == e, i};
}
\end{minted}

\needspace{17\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Lower Bound}
\addcontentsline{toc}{subsubsection}{Lower Bound}
\begin{minted}{cpp}
// ans[0] = true if e is in v else false
// ans[1] = index pointing to the first element in
// the range [l, r] which compares >= to e.

// O(lg(r - l)) [l, r]
template <class T>
vector<int> lowerBound(vector<T>& v, int l, int r,
                       T e) {
  int rr = r;
  while (l <= r) {
    int mid = l + (r - l) >> 1;
    e <= v[mid] ? r = mid - 1, l = mid + 1;
  }
  return {v[min(rr, l)] == e, l};
}
\end{minted}

\needspace{17\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Upper Bound}
\addcontentsline{toc}{subsubsection}{Upper Bound}
\begin{minted}{cpp}
// ans[0] = true if e is in v else false
// ans[1] = index pointing to the first element in
// the range [l, r] which compares > to e.

// O(lg(r - l)) [l, r]
template <class T>
vector<int> upperBound(vector<T>& v, int l, int r,
                       T e) {
  int ll = l;
  while (l <= r) {
    int mid = l + (r - l) >> 1;
    e < v[mid] ? r = mid - 1, l = mid + 1;
  }
  return {v[max(ll, r)] == e, l};
}
\end{minted}

\needspace{7\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Multiple Queries}
\addcontentsline{toc}{subsection}{Multiple Queries}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Mo}
\addcontentsline{toc}{subsubsection}{Mo}
\begin{minted}{cpp}
// q = query
// qs = queries
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
struct Query {
  int l, r;
};
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
int blksize;
vector<Query> qs;
vector<int> arr;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void initVars(int N, int M) {
  arr = vector<int>(N);
  qs = vector<Query>(M);
}
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
bool cmp(Query &a, Query &b) {
  if (a.l == b.l) return a.r < b.r;
  return a.l / blksize < b.l / blksize;
}
\end{minted}
\vspace{-12pt}
\needspace{28\baselineskip}
\begin{minted}{cpp}
void getResults() {
  blksize = (int)sqrt(arr.size());
  sort(qs.begin(), qs.end(), cmp);
  int prevL = 0, prevR = -1;
  int sum = 0;
  for (auto &q : qs) {
    int L = q.l, R = q.r;
    while (prevL < L) {
      sum -= arr[prevL];  // problem specific
      prevL++;
    }
    while (prevL > L) {
      prevL--;
      sum += arr[prevL];  // problem specific
    }
    while (prevR < R) {
      prevR++;
      sum += arr[prevR];  // problem specific
    }
    while (prevR > R) {
      sum -= arr[prevR];  // problem specific
      prevR--;
    }

    cout << "sum[" << L << ", " << R << "] = " << sum
         << endl;
  }
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
int main() {
  initVars(9, 2);
  arr = {1, 1, 2, 1, 3, 4, 5, 2, 8};
  qs = {{0, 8}, {3, 5}};
  getResults();
}
\end{minted}

\needspace{6\baselineskip}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{SQRT Decomposition}
\addcontentsline{toc}{subsubsection}{SQRT Decomposition}
\begin{minted}{cpp}
// sum of elements in range
int neutro = 0;
vector<int> arr;
vector<int> blks;
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
void initVars(int n) {
  arr.assign(n, neutro);
  blks.assign(sqrt(n), neutro);
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
void preprocess() {
  for (int i = 0, j = 0; i < arr.size(); i++) {
    if (i == blks.size() * j) j++;
    blks[j - 1] += arr[i];  // problem specific
  }
}
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
// problem specific
void update(int i, int val) {
  blks[i / blks.size()] += val - arr[i];
  arr[i] = val;
}
\end{minted}
\vspace{-12pt}
\needspace{19\baselineskip}
\begin{minted}{cpp}
int query(int l, int r) {
  int sum = 0;
  int lblk = l / blks.size();
  if (l != blks.size() * lblk++)
    while (l < r && l != lblk * blks.size()) {
      sum += arr[l];  // problem specific
      l++;
    }

  while (l + blks.size() <= r) {
    sum += blks[l / blks.size()];  // problem specific
    l += blks.size();
  }
  while (l <= r) {
    sum += arr[l];  // problem specific
    l++;
  }
  return sum;
}
\end{minted}
\vspace{-12pt}
\needspace{15\baselineskip}
\begin{minted}{cpp}
int main() {
  initVars(10);
  arr = {1, 5, 2, 4, 6, 1, 3, 5, 7, 10};
  preprocess();
  for (int i = 0; i < blks.size() + 1; i++)
    cout << blks[i] << " ";
  // output: 8 11 15 10
  cout << endl;
  cout << query(3, 8) << " ";
  cout << query(1, 6) << " ";
  update(8, 0);
  cout << query(8, 8) << endl;
  // output: 26 21 0
  return 0;
}
\end{minted}

\needspace{18\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Trees And Heaps}
\markboth{TREES AND HEAPS}{}
\addcontentsline{toc}{section}{Trees And Heaps}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Red Black Tree}
\addcontentsline{toc}{subsection}{Red Black Tree}
\begin{minted}{cpp}
template <class K, class V>
struct RedBlackTree {
  struct Node {
    K key;
    V val;
    Node *l = nullptr, *r = nullptr;  // left, right
    bool isRed;
    Node(K k, V v, bool isRed)
        : key(k), val(v), isRed(isRed) {}
  };

  Node *root = nullptr;
  
  int compare(K a, K b) { return a < b ? -1 : a > b; }
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  V get(K key) {
    Node *t = root;
    while (t)
      if (key == t->key) return t->val;
      else if (key < t->key) t = t->l;
      else t = t->r;
    throw "Key doesn't exist";
  }
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  Node *rotateLeft(Node *t) {
    Node *x = t->r;
    t->r = x->l;
    x->l = t;
    x->isRed = t->isRed;
    t->isRed = 1;
    return x;
  }
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  Node *rotateRight(Node *t) {
    Node *x = t->l;
    t->l = x->r;
    x->r = t;
    x->isRed = t->isRed;
    t->isRed = 1;
    return x;
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  void flipColors(Node *t) {
    t->isRed = 1;
    t->l->isRed = 0;
    t->r->isRed = 0;
  }
\end{minted}
\vspace{-12pt}
\needspace{16\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  Node *insert(Node *t, K key, V val) {
    if (!t) return new Node(key, val, 1);
    int cmp = compare(key, t->key);
    if (!cmp) t->val = val;
    if (cmp < 0) t->l = insert(t->l, key, val);
    if (cmp > 0) t->r = insert(t->r, key, val);
    if (t->r && t->r->isRed && !(t->l && t->l->isRed))
      t = rotateLeft(t);
    if (t->l && t->l->isRed && t->l->l &&
        t->l->l->isRed)
      t = rotateRight(t);
    if (t->l && t->l->isRed && t->r && t->r->isRed)
      flipColors(t);
    return t;
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void insert(K key, V val) {
    root = insert(root, key, val);
  }
};
\end{minted}

\needspace{13\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Treap}
\addcontentsline{toc}{subsection}{Treap}
\begin{minted}{cpp}
template <class K, class V>
struct Treap {
  struct Node {
    Node *l = nullptr, *r = nullptr;  // left, right
    K key;
    V val;
    int prior, sz = 1;
    Node(K k, V v, int p = rand())
        : key(k), val(v), prior(p) {}
  };
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
  Treap() {}
  Node *root = nullptr;
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  V get(K key) {
    Node *t = root;
    while (t)
      if (key == t->key) return t->val;
      else if (key < t->key) t = t->l;
      else t = t->r;
    throw runtime_error("Treap: Key doesn't exist");
  }
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
  // O(1)
  void updateSize(Node *t) {
    if (!t) return;
    t->sz = 1;
    if (t->l) t->sz += t->l->sz;
    if (t->r) t->sz += t->r->sz;
  }
\end{minted}
\vspace{-12pt}
\needspace{11\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), first <= key < second
  pair<Node *, Node *> split(Node *t, K key) {
    if (!t) return {NULL, NULL};
    Node *left, *right;
    if (key < t->key)
      tie(left, t->l) = split(t->l, key), right = t;
    else
      tie(t->r, right) = split(t->r, key), left = t;
    updateSize(t);
    return {left, right};
  }
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void insert(Node *&t, Node *v) {
    if (!t) t = v;
    else if (v->prior > t->prior)
      tie(v->l, v->r) = split(t, v->key), t = v;
    else insert(v->key < t->key ? t->l : t->r, v);
    updateSize(t);
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void insert(K key, V val) {
    insert(root, new Node(key, val));
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)) asumes a.keys < b.keys
  Node *merge(Node *a, Node *b) {
    Node *ans;
    if (!a || !b) ans = a ? a : b;
    else if (a->prior > b->prior)
      a->r = merge(a->r, b), ans = a;
    else b->l = merge(a, b->l), ans = b;
    updateSize(ans);
    return ans;
  }
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void erase(Node *&t, K key) {
    if (!t) return;
    if (t->key == key) t = merge(t->l, t->r);
    else erase(key < t->key ? t->l : t->r, key);
    updateSize(t);
  }
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void erase(K key) { erase(root, key); }
\end{minted}
\vspace{-12pt}
\needspace{11\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)) 1-indexed (k-th smallest)
  K kth(int k) {
    Node *t = root;
    while (t) {
      int sz = t->l ? t->l->sz : 0;
      if (sz + 1 == k) return t->key;
      else if (k > sz) t = t->r, k -= sz + 1;
      else t = t->l;
    }
    throw runtime_error("Treap: Index out of bounds");
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(M * lg(N / M))
  Node *join(Node *a, Node *b) {
    if (!a || !b) return a ? a : b;
    if (a->prior < b->prior) swap(a, b);
    Node *l, *r;
    tie(l, r) = split(b, a->key);
    a->l = join(a->l, l), a->r = join(a->r, r);
    updateSize(a);
    return a;
  }
\end{minted}
\vspace{-12pt}
\needspace{3\baselineskip}
\begin{minted}{cpp}
  void join(Treap<K, V> t) {
    root = join(root, t.root);
  }
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
  // O(N)
  Node *copy(Node *t) {
    if (!t) return nullptr;
    Node *x = new Node(t->key, t->val, t->prior);
    x->l = copy(t->l), x->r = copy(t->r);
    return x;
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  void print(string s, Node *t, bool isleft) {
    if (!t) return;
    cout << s << (isleft ? "|__" : "\\__");
    cout << t->val << "~" << t->prior << endl;
    print(s + (isleft ? "|   " : "    "), t->l, 1);
    print(s + (isleft ? "|   " : "    "), t->r, 0);
  }

  void print() { print("", root, false); }
};
\end{minted}

\needspace{6\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Treap (Implicit)}
\addcontentsline{toc}{subsection}{Treap (Implicit)}
\begin{minted}{cpp}
// su = sum update, ru = replace update, rev = reverse
// psu = pending sum update, sz = size
// pru = pending replace update
\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
template <class T>
struct ImplicitTreap {
  struct Node {
    Node *l = nullptr, *r = nullptr;  // left, right
    T val, minim = (1 << 30), sum = 0, su = 0, ru;
    int prior, sz = 1, rev = 0, psu = 0, pru = 0;
    Node(T e, int p = rand()) : val(e), prior(p) {}
  };
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
  ImplicitTreap() {}
  Node *root = nullptr;
\end{minted}
\vspace{-12pt}
\needspace{13\baselineskip}
\begin{minted}{cpp}
  // O(1)
  void pull(Node *t) {
    if (!t) return;
    t->sz = 1, t->sum = t->val, t->minim = t->val;
    if (t->l) {
      t->sz += t->l->sz, t->sum += t->l->sum;
      t->minim = min(t->minim, t->l->minim);
    }
    if (t->r) {
      t->sz += t->r->sz, t->sum += t->r->sum;
      t->minim = min(t->minim, t->r->minim);
    }
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  void applySu(Node *t, T su) {
    if (!t) return;
    t->val += su, t->psu = 1, t->su += su;
    t->sum += su * t->sz, t->minim += su;
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  void applyRev(Node *t) {
    if (!t) return;
    t->rev ^= 1, swap(t->l, t->r);
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  void applyRu(Node *t, T ru) {
    if (!t) return;
    t->val = ru, t->pru = 1, t->ru = ru;
    t->sum = ru * t->sz, t->minim = ru;
  }
\end{minted}
\vspace{-12pt}
\needspace{12\baselineskip}
\begin{minted}{cpp}
  // O(1)
  void push(Node *t) {
    if (!t) return;
    if (t->psu) {
      applySu(t->l, t->su), applySu(t->r, t->su);
      t->psu = t->su = 0;
    }
    if (t->rev)
      applyRev(t->l), applyRev(t->r), t->rev = 0;
    if (t->pru) {
      applyRu(t->l, t->ru), applyRu(t->r, t->ru);
      t->pru = 0;
    }
  }
\end{minted}
\vspace{-12pt}
\needspace{16\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), first <= idx < second
  pair<Node *, Node *> split(Node *t, int idx,
                             int cnt = 0) {
    if (!t) return {NULL, NULL};
    push(t);
    Node *left, *right;
    int idxt = cnt + (t->l ? t->l->sz : 0);
    if (idx < idxt)
      tie(left, t->l) = split(t->l, idx, cnt),
                right = t;
    else
      tie(t->r, right) = split(t->r, idx, idxt + 1),
                left = t;
    pull(t);
    return {left, right};
  }
\end{minted}
\vspace{-12pt}
\needspace{11\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void insert(Node *&t, Node *v, int idxv, int cnt) {
    int idxt = t ? cnt + (t->l ? t->l->sz : 0) : 0;
    push(t);
    if (!t) t = v;
    else if (v->prior > t->prior)
      tie(v->l, v->r) = split(t, idxv, cnt), t = v;
    else if (idxv < idxt) insert(t->l, v, idxv, cnt);
    else insert(t->r, v, idxv, idxt + 1);
    pull(t);
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), insert element in i-th position
  void insert(T e, int i) {
    insert(root, new Node(e), i - 1, 0);
  }
\end{minted}
\vspace{-12pt}
\needspace{11\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)) asumes a.indexes < b.indexes
  Node *merge(Node *a, Node *b) {
    push(a), push(b);
    Node *ans;
    if (!a || !b) ans = a ? a : b;
    else if (a->prior > b->prior)
      a->r = merge(a->r, b), ans = a;
    else b->l = merge(a, b->l), ans = b;
    pull(ans);
    return ans;
  }
\end{minted}
\vspace{-12pt}
\needspace{10\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void erase(Node *&t, int idx, int cnt = 0) {
    if (!t) return;
    push(t);
    int idxt = cnt + (t->l ? t->l->sz : 0);
    if (idxt == idx) t = merge(t->l, t->r);
    else if (idx < idxt) erase(t->l, idx, cnt);
    else erase(t->r, idx, idxt + 1);
    pull(t);
  }
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), erase element at i-th position
  void erase(int i) { erase(root, i); }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void push_back(T e) {
    root = merge(root, new Node(e));
  }
\end{minted}
\vspace{-12pt}
\needspace{7\baselineskip}
\begin{minted}{cpp}
  // O(lg(N))
  void op(int l, int r, function<void(Node *&)> f) {
    Node *a, *b, *c;
    tie(a, b) = split(root, l - 1);
    tie(b, c) = split(b, r - l);
    f(b), root = merge(a, merge(b, c));
  }
\end{minted}
\vspace{-12pt}
\needspace{4\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), reverses [l, ..., r]
  void reverse(int l, int r) {
    op(l, r, [&](Node *&t) { applyRev(t); });
  }
\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), rotates [l, ..., r] k times
  void rotate(int l, int r, int k) {
    op(l, r, [&](Node *&t) {
      Node *l, *r;
      k %= t->sz, tie(l, r) = split(t, t->sz - k - 1);
      t = merge(r, l);
    });
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), adds val to [l, ..., r]
  void add(int l, int r, T val) {
    op(l, r,
       [&](Node *&t) { applySu(t, val); });
  }
\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), sets val to [l, ..., r]
  void replace(int l, int r, T val) {
    op(l, r,
       [&](Node *&t) { applyRu(t, val); });
  }
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), minimum in [l, ..., r]
  T getMin(int l, int r) {
    T ans;
    op(l, r, [&](Node *&t) { ans = t->minim; });
    return ans;
  }
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
  // O(lg(N)), sum in [l, ..., r]
  T getSum(int l, int r) {
    T ans;
    op(l, r, [&](Node *&t) { ans = t->sum; });
    return ans;
  }
  \end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
  // O(N)
  void print(Node *t) {
    if (!t) return;
    push(t);
    print(t->l);
    cout << t->val << " ";
    print(t->r);
  }
\end{minted}
\vspace{-12pt}
\needspace{2\baselineskip}
\begin{minted}{cpp}
  void print() { print(root), cout << endl; }
};
\end{minted}

\needspace{16\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Util}
\markboth{UTIL}{}
\addcontentsline{toc}{section}{Util}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Ceil Of Division Between Integers}
\addcontentsline{toc}{subsection}{Ceil Of Division Between Integers}
\begin{minted}{cpp}
typedef long long int li;

int sign(li x) { return x < 0 ? -1 : x > 0; }

//         a / b
li ceil(li a, li b) {
  if (sign(a) == sign(b) && a % b) return a / b + 1;
  else return a / b;
}
\end{minted}

\needspace{15\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Compare 2 Strings}
\addcontentsline{toc}{subsection}{Compare 2 Strings}
\begin{minted}{cpp}
// O(min(|a|, |b|)) -1: a < b, 0: a == b, 1: a > b
int comp(string &a, string &b) {
  int ans = -1, same = 1;
  for (int i = 0; i < min(a.size(), b.size()); i++) {
    if (a[i] != b[i]) same = 0;
    if (a[i] > b[i]) ans = 1;
  }
  if (same)
    ans = a.size() < b.size() ? -1
                              : a.size() > b.size();
  return ans;
}
\end{minted}

\needspace{12\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Double Comparisons With Given Precision}
\addcontentsline{toc}{subsection}{Double Comparisons With Given Precision}
\begin{minted}{cpp}
typedef long double ld;
const ld eps = 1e-9;

bool eq(ld a, ld b) { return abs(a - b) <= eps; }
bool neq(ld a, ld b) { return abs(a - b) > eps; }
bool gt(ld a, ld b) { return a - b > eps; }
bool lt(ld a, ld b) { return b - a > eps; }
bool gte(ld a, ld b) { return a - b >= -eps; }
bool lte(ld a, ld b) { return b - a >= -eps; }
\end{minted}

\needspace{12\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Floor Of Division Between Integers}
\addcontentsline{toc}{subsection}{Floor Of Division Between Integers}
\begin{minted}{cpp}
typedef long long int li;

int sign(li x) { return x < 0 ? -1 : x > 0; }

//          a / b
li floor(li a, li b) {
  if (sign(a) != sign(b) && a % b) return a / b - 1;
  else return a / b;
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Get Sign Of Number}
\addcontentsline{toc}{subsection}{Get Sign Of Number}
\begin{minted}{cpp}
int sign(int x) { return x < 0 ? -1 : x > 0; }
\end{minted}

\needspace{8\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Modulo with negative numbers}
\addcontentsline{toc}{subsection}{Modulo with negative numbers}
\begin{minted}{cpp}
typedef long long int li;

// if m is positive the answer is positive
// if m is negative the answer is negative
li mod(li a, li m) { return (m + (a % m)) % m; }
\end{minted}

\needspace{9\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\subsectionfont{\fileTitleStyle}
\subsection*{Number To String}
\addcontentsline{toc}{subsection}{Number To String}
\begin{minted}{cpp}
string toString(int n) {
  string ans = "";
  for (; n; n /= 10) ans += (n % 10) + '0';
  reverse(ans.begin(), ans.end());
  return ans;
}
\end{minted}

\end{multicols*}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Extras}
\markboth{EXTRAS}{}
\addcontentsline{toc}{section}{Extras}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Data Structures}
\addcontentsline{toc}{subsection}{Data Structures}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\vspace{0em}
\subsubsection*{Strings}
\addcontentsline{toc}{subsubsection}{Strings}
\vspace{2em}
\paragraphfont{\centering\bfseries\large}
\paragraphfont{\fileTitleStyle}
\paragraph*{Suffix Automaton}
\addcontentsline{toc}{paragraph}{Suffix Automaton}
\vspace{1em}
\sffamily
\begin{itemize}[label={\bullet}]
  \item Each node $u$ corresponds to an endpos-equivalence class for which its longest suffix corresponds to the path from root to $u$.
\end{itemize}
\begin{multicols*}{2}
\end{multicols*}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{C++}
\addcontentsline{toc}{subsection}{C++}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Automatic Type Conversions}
\addcontentsline{toc}{subsubsection}{Automatic Type Conversions}
\vspace{1em}
\sffamily

When performing operations with different primitive data types in C++,
the operand with smaller rank gets converted to the data type of the operand
with the greater rank.

\begin{center}
\begin{tabular}{| >{\centering}m{1cm}|m{7cm}|}
\hline
\multicolumn{2}{|c|}{\textbf{Data Type Ranks}}
\tabularnewline \hline
\textbf{Rank}
&
\centering
\textbf{Data Type}
\tabularnewline \hline
1
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
bool
\end{minted}
\end{minipage}
\tabularnewline \hline
2
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
char, signed char, unsigned char
\end{minted}
\end{minipage}
\tabularnewline \hline
3
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
short int, unsigned short int
\end{minted}
\end{minipage}
\tabularnewline \hline
4
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
int, unsigned int
\end{minted}
\end{minipage}
\tabularnewline \hline
5
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
long int, unsigned long int
\end{minted}
\end{minipage}
\tabularnewline \hline
6
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
long long int, unsigned long long int
\end{minted}
\end{minipage}
\tabularnewline \hline
7
&
{\fontfamily{lmtt}\selectfont\textcolor{pinegreen}{\textbf{\_\_int128\_t}}}
\tabularnewline \hline
8
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
float
\end{minted}
\end{minipage}
\tabularnewline \hline
9
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
double
\end{minted}
\end{minipage}
\tabularnewline \hline
10
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
long double
\end{minted}
\end{minipage}
\tabularnewline \hline
\end{tabular}
\end{center}
\vspace{1em}
Source: \textcolor{prussianblue}{https://en.cppreference.com/w/c/language/conversion}
\begin{multicols*}{2}
\end{multicols*}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Integer Types Properties}
\addcontentsline{toc}{subsubsection}{Integer Types Properties}
\vspace{1em}
\sffamily
\begin{center}
\begin{tabular}{| >{\centering}m{3cm}|m{7cm}|}
\hline
\multicolumn{2}{|c|}{\textbf{Properties}}
\tabularnewline \hline
\textbf{Width in bits}
&
\centering
\textbf{Data Type}
\tabularnewline \hline
\textbf{8}
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
bool
\end{minted}
\end{minipage}
\tabularnewline \hline
At least \textbf{8}
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
char, signed char, unsigned char
\end{minted}
\end{minipage}
\tabularnewline \hline
At least \textbf{16}
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
short int, unsigned short int
\end{minted}
\end{minipage}
\tabularnewline \hline
At least \textbf{16}
&
\begin{minipage}[c]{5cm}
\begin{minted}{cpp}
int, unsigned int
\end{minted}
\end{minipage}
\tabularnewline \hline
At least \textbf{32}
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
long int, unsigned long int
\end{minted}
\end{minipage}
\tabularnewline \hline
At least \textbf{64}
&
\begin{minipage}[c]{\linewidth}
\begin{minted}{cpp}
long long int, unsigned long long int
\end{minted}
\end{minipage}
\tabularnewline \hline
\textbf{128}
&
{\fontfamily{lmtt}\selectfont\textcolor{pinegreen}{\textbf{\_\_int128\_t}}}
\tabularnewline \hline
\end{tabular}
\end{center}
Sources:\\
\hangindent=2em
\textcolor{prussianblue}{https://en.cppreference.com/w/cpp/language/types}\\
\textcolor{prussianblue}{https://www.geeksforgeeks.org/c-data-types/}\\
\textcolor{prussianblue}{https://stackoverflow.com/questions/2064550/c-why-bool-is-8-bits-long}
\begin{multicols*}{2}
\needspace{5\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Generators}
\addcontentsline{toc}{subsection}{Generators}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Tree Generator}
\addcontentsline{toc}{subsubsection}{Tree Generator}
\begin{minted}{py}
from random import randint
from sys import stdout
import subprocess

n = randint(2, 10)
cout = f"{n}\n"
for i in range(n):
    if i:
        cout += " "
    cout += f"{randint(1, 10)}"

cout += "\n"

for i in range(2, n + 1):
    u = i
    v = randint(1, i - 1)
    cout += f"{u} {v}\n"

with open('in', 'r') as f: cout = f.read()

stdout.write(cout)
stdout.write("================\n")

with open('in', 'w+') as f: f.write(cout)

# subprocess.run("g++ -std=c++14 sol.cpp -o sol", shell=True)
# subprocess.run("g++ -std=c++14 brute.cpp -o brute", shell=True)
subprocess.run("./brute < in > outb && ./sol < in > outs", shell=True)
with open('outb', 'r') as f:
    ans1 = f.read()
ans1 = ans1.split('\n')[:-1]
with open('outs', 'r') as f:
    ans2 = f.read()

ans2 = ans2.split('\n')[:-1]
for i in range(max(len(ans1), len(ans2))):
    left = "--"
    right = "--"
    if (i < len(ans1)): left = ans1[i]
    if (i < len(ans2)): right = ans2[i]
    stdout.write(f"{left: <7} |  {right}\n")
stdout.write('\n')

# subprocess.run("diff outb outs", shell=True)
\end{minted}

\end{multicols*}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Maths}
\addcontentsline{toc}{subsection}{Maths}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Common Sums}
\addcontentsline{toc}{subsubsection}{Common Sums}
\vspace{1em}
\sffamily
\bgroup
\def\arraystretch{3}
{\normalsize
  \begin{center}
    \begin{tabular}{| >{\centering}m{5cm}| >{\centering}m{5cm}| >{\centering}m{5cm}|}
      \hline
      $\sum_{k = 0}^n k = \frac{n(n + 1)}{2}$
       &
      $\sum_{k = 0}^n k^2 = \frac{n(n + 1)(2n + 1)}{6}$
       &
      $\sum_{k = 0}^n k^3 = \frac{n^2(n + 1)^2}{4}$
      \tabularnewline \hline
      \multicolumn{2}{|c|}{$\sum_{k = 0}^n k^4 = \frac{n}{30} (n + 1)(2n + 1)(3n^2 + 3n - 1)$}
       &
      $\sum_{k = 0}^n a^k = \frac{1 - a^{n + 1}}{1 - a}$
      \tabularnewline \hline
      $\sum_{k = 0}^n ka^k = \frac{a[1 - (n + 1)a^n + na^{n + 1}]}{(1 - a)^2}$
       &
      \multicolumn{2}{c|}{
      $\sum_{k = 0}^n k^2a^k = \frac{a[(1 + a) - (n + 1)^2a^n + (2n^2 + 2n - 1)a^{n + 1} - n^2a^{n + 2}]}{(1 - a)^3}$
      }
      \tabularnewline \hline
      $\sum_{k = 0}^\infty a^k = \frac{1}{1 - a}, |a| < 1$
       &
      $\sum_{k = 0}^\infty ka^k = \frac{a}{(1 - a)^2}, |a| < 1$
       &
      $\sum_{k = 0}^\infty k^2a^k = \frac{a^2 + a}{(1 - a)^3}, |a| < 1$
      \tabularnewline \hline
      $\sum_{k = 0}^\infty \frac{1}{a^k} = \frac{a}{a - 1}, |a| > 1$
       &
      $\sum_{k = 0}^\infty \frac{k}{a^k} = \frac{a}{(a - 1)^2}, |a| > 1$
       &
      $\sum_{k = 0}^\infty \frac{k^2}{a^k} = \frac{a^2 + a}{(a - 1)^3}, |a| > 1$
      \tabularnewline \hline
      $\sum_{k = 0}^\infty \frac{a^k}{k!} = e^a$
       &
      $\sum_{k = 0}^n \binom{n}{k} = 2^n$
       &
      $\sum_{k = 0}^n \binom{k}{m} = \binom{n + 1}{m + 1}$
      \tabularnewline \hline
    \end{tabular}
  \end{center}
}
\egroup
\vspace{1em}
\begin{multicols*}{2}
\end{multicols*}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Logarithm Rules}
\addcontentsline{toc}{subsubsection}{Logarithm Rules}
\vspace{1em}
\sffamily
\bgroup
\def\arraystretch{2}
{\normalsize
\begin{center}
  \begin{tabular}{| >{\centering}m{5cm}| >{\centering}m{5cm}| >{\centering}m{5cm}|}
    \hline
    $\log_b(b^k) = k$
     &
    $\log_b(1) = 0$
     &
    $\log_b(X) = \frac{\log_c(X)}{\log_c(b)}$
    \tabularnewline \hline
    $\log_b(X \cdotp Y) = \log_b(X) + \log_b(Y)$
     &
    $\log_b(\frac{X}{Y}) = \log_b(X) - \log_b(Y)$
     &
    $\log_b(X^k) = k \cdotp \log_b(X)$
    \tabularnewline \hline
  \end{tabular}
\end{center}
}
\egroup
\vspace{1em}
\begin{multicols*}{2}
\end{multicols*}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Permutation Formula}
\addcontentsline{toc}{subsubsection}{Permutation Formula}
\vspace{1em}
\sffamily
\bgroup

The number of permutations of $n$ elements with $x_1$ identical elements of type $1$,
$x_2$ identical elements of type 2, $\cdots$, and $x_k$ identical elements of type $k$ is:

$$\frac{n!}{x_1! \cdot x_2! \cdot ... \cdot x_k!}$$

Note: Extra available spaces $S$ can be considered as $S$ identical elements of type $space$.

\egroup
\vspace{1em}
\begin{multicols*}{2}
\end{multicols*}
\subsubsectionfont{\centering\bfseries\Large}
\vspace{0em}
\subsubsection*{Trigonometry}
\addcontentsline{toc}{subsubsection}{Trigonometry}
\vspace{2em}
\paragraphfont{\centering\bfseries\large}
\paragraphfont{\fileTitleStyle}
\paragraph*{Area Of A Triangle}
\addcontentsline{toc}{paragraph}{Area Of A Triangle}
\vspace{1em}
\sffamily
\bgroup

$$\frac{1}{2} ab \cdot sin(\theta)$$

- Where $\theta$ is the angle between side $a$ and side $b$.
\egroup
\vspace{1em}
\begin{multicols*}{2}
\end{multicols*}
\paragraphfont{\centering\bfseries\large}
\paragraphfont{\fileTitleStyle}
\paragraph*{Law Of Cosines}
\addcontentsline{toc}{paragraph}{Law Of Cosines}
\vspace{1em}
\sffamily
\bgroup

$$c^2 = a^2 + b^2 - 2 a b \cdot cos(\theta)$$

- Where $\theta$ is the angle between the sides $a$ and $b$.

\egroup
\vspace{1em}
\begin{multicols*}{2}
\end{multicols*}
\paragraphfont{\centering\bfseries\large}
\paragraphfont{\fileTitleStyle}
\paragraph*{Law Of Sines}
\addcontentsline{toc}{paragraph}{Law Of Sines}
\vspace{1em}
\sffamily
\bgroup

$$\frac{a}{sin(\alpha)} = \frac{b}{sin(\beta)} = \frac{c}{sin(\sigma)}$$

- Where $\alpha$ is the opposite angle of the side $a$, $\beta$ the opposite angle of the side $b$
and $\sigma$ is the opposite angle of the side $c$.

\egroup
\vspace{1em}
\begin{multicols*}{2}
\needspace{18\baselineskip}
\sectionfont{\centering\bfseries\Huge}
\vspace{1em}
\section*{Problems Solved}
\markboth{PROBLEMS SOLVED}{}
\addcontentsline{toc}{section}{Problems Solved}
\vspace{3em}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Arrays}
\addcontentsline{toc}{subsection}{Arrays}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{Inversions Count}
\addcontentsline{toc}{subsubsection}{Inversions Count}
\begin{minted}{cpp}
typedef long long int li;
#include "../../Ranges/Data Structures/BIT.cpp"

li invCount(vector<li>& v, li ans = 0) {
  BIT<int> bit(*max_element(v.begin(), v.end()) + 1);
  for (int i = 0; i < v.size(); i++)
    ans += i - bit.query(v[i]), bit.update(v[i], 1);
  return ans;
}
\end{minted}
\vspace{-12pt}
\needspace{6\baselineskip}
\begin{minted}{cpp}
li invCount2(vector<li>& v, li ans = 0) {
  BIT<int> bit(*max_element(v.begin(), v.end()) + 1);
  for (int i = v.size() - 1; ~i; i--)
    ans += bit.query(v[i] - 1), bit.update(v[i], 1);
  return ans;
}
\end{minted}

\needspace{26\baselineskip}
\subsectionfont{\centering\bfseries\LARGE}
\vspace{0em}
\subsection*{Maths}
\addcontentsline{toc}{subsection}{Maths}
\vspace{2em}
\subsubsectionfont{\centering\bfseries\Large}
\subsubsectionfont{\fileTitleStyle}
\subsubsection*{N As Sum Of Consecutive Numbers}
\addcontentsline{toc}{subsubsection}{N As Sum Of Consecutive Numbers}
\begin{minted}{cpp}
int main() {
  long long int x;
  cin >> x;
  auto divs = getDivisors(2 * x);
  int cnt = 0;
  auto check = [&](long long int a, long long int b) {
    long long int r = a - 1;
    if (r < 1 or (b - r) % 2 != 0) return false;
    long long int d = (b - r) / 2;
    if (d <= 0) return false;
    for (int i = 0; i <= r; i++)
      cout << d + i << " \n"[i == r];
    return true;
  };
  for (int i = 1; i < (int)divs.size(); i += 2) {
    long long int a = divs[i - 1], b = divs[i];
    if (check(a, b)) cnt++;
    if (check(b, a)) cnt++;
  }
  cout << cnt << endl;
}
\end{minted}

\end{multicols*}

\end{document}
